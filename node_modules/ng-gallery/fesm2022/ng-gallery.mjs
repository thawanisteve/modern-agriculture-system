import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Optional, Inject, Component, ChangeDetectionStrategy, Input, EventEmitter, Directive, Output, ViewChild, HostListener, HostBinding, QueryList, ViewChildren, booleanAttribute, numberAttribute, ContentChild, NgModule } from '@angular/core';
import { filter, Subject, BehaviorSubject, switchMap, of, expand, takeWhile, takeUntil, finalize, merge, Observable, fromEvent, take, map, mergeMap, EMPTY, combineLatest, tap, debounceTime, animationFrameScheduler, firstValueFrom, distinctUntilChanged, startWith, delay } from 'rxjs';
import * as i1 from '@angular/common';
import { CommonModule, DOCUMENT, NgIf, NgFor, NgSwitch, NgSwitchCase } from '@angular/common';
import { coerceCssPixelValue } from '@angular/cdk/coercion';
import * as i1$1 from '@angular/platform-browser';
import * as i1$2 from '@angular/cdk/bidi';
import { Dir } from '@angular/cdk/bidi';
import * as i2 from '@angular/cdk/platform';
import { getRtlScrollAxisType, RtlScrollAxisType } from '@angular/cdk/platform';
import { trigger, transition, style, animate } from '@angular/animations';

var GalleryAction;
(function (GalleryAction) {
    GalleryAction["INITIALIZED"] = "initialized";
    GalleryAction["ITEMS_CHANGED"] = "itemsChanged";
    GalleryAction["INDEX_CHANGED"] = "indexChanged";
    GalleryAction["PLAY"] = "play";
    GalleryAction["STOP"] = "stop";
})(GalleryAction || (GalleryAction = {}));
var ImageSize;
(function (ImageSize) {
    ImageSize["Cover"] = "cover";
    ImageSize["Contain"] = "contain";
})(ImageSize || (ImageSize = {}));
var LoadingStrategy;
(function (LoadingStrategy) {
    LoadingStrategy["Preload"] = "preload";
    LoadingStrategy["Lazy"] = "lazy";
    LoadingStrategy["Default"] = "default";
})(LoadingStrategy || (LoadingStrategy = {}));
var LoadingAttr;
(function (LoadingAttr) {
    LoadingAttr["Eager"] = "eager";
    LoadingAttr["Lazy"] = "lazy";
})(LoadingAttr || (LoadingAttr = {}));
var ThumbnailsPosition;
(function (ThumbnailsPosition) {
    ThumbnailsPosition["Top"] = "top";
    ThumbnailsPosition["Left"] = "left";
    ThumbnailsPosition["Right"] = "right";
    ThumbnailsPosition["Bottom"] = "bottom";
})(ThumbnailsPosition || (ThumbnailsPosition = {}));
var BulletsPosition;
(function (BulletsPosition) {
    BulletsPosition["Top"] = "top";
    BulletsPosition["Bottom"] = "bottom";
})(BulletsPosition || (BulletsPosition = {}));
var CounterPosition;
(function (CounterPosition) {
    CounterPosition["Top"] = "top";
    CounterPosition["Bottom"] = "bottom";
})(CounterPosition || (CounterPosition = {}));
var Orientation;
(function (Orientation) {
    Orientation["Horizontal"] = "horizontal";
    Orientation["Vertical"] = "vertical";
})(Orientation || (Orientation = {}));
var GalleryItemTypes;
(function (GalleryItemTypes) {
    GalleryItemTypes["Image"] = "image";
    GalleryItemTypes["Video"] = "video";
    GalleryItemTypes["Youtube"] = "youtube";
    GalleryItemTypes["Vimeo"] = "vimeo";
    GalleryItemTypes["Iframe"] = "iframe";
})(GalleryItemTypes || (GalleryItemTypes = {}));

/** Initial state */
const defaultState = {
    action: GalleryAction.INITIALIZED,
    isPlaying: false,
    hasNext: false,
    hasPrev: false,
    currIndex: 0,
    items: []
};
const defaultConfig = {
    nav: true,
    loop: false,
    bullets: false,
    thumbs: false,
    debug: false,
    bulletSize: 6,
    counter: false,
    autoplay: false,
    thumbWidth: 120,
    thumbHeight: 90,
    disableBullets: false,
    disableThumbs: false,
    disableScroll: false,
    disableThumbScroll: false,
    disableMouseScroll: false,
    disableThumbMouseScroll: false,
    autoplayInterval: 3000,
    scrollDuration: 468,
    scrollEase: {
        x1: 0.42,
        y1: 0,
        x2: 0.58,
        y2: 1
    },
    thumbCentralized: false,
    thumbAutosize: false,
    itemAutosize: false,
    autoHeight: false,
    scrollBehavior: 'smooth',
    resizeDebounceTime: 0,
    loadingAttr: LoadingAttr.Lazy,
    imageSize: ImageSize.Contain,
    thumbImageSize: ImageSize.Cover,
    bulletPosition: BulletsPosition.Bottom,
    counterPosition: CounterPosition.Top,
    thumbPosition: ThumbnailsPosition.Bottom,
    loadingStrategy: LoadingStrategy.Preload,
    orientation: Orientation.Horizontal,
    navIcon: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M0 256C0 397.4 114.6 512 256 512s256-114.6 256-256S397.4 0 256 0S0 114.6 0 256zM241 377c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l87-87-87-87c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0L345 239c9.4 9.4 9.4 24.6 0 33.9L241 377z"/></svg>`,
    // navIcon: `<?xml version="1.0" encoding="UTF-8"?><svg width="512px" height="512px" enable-background="new 0 0 240.823 240.823" version="1.1" viewBox="0 0 240.823 240.823" xml:space="preserve" xmlns="http://www.w3.org/2000/svg"><path d="m183.19 111.82l-108.3-108.26c-4.752-4.74-12.451-4.74-17.215 0-4.752 4.74-4.752 12.439 0 17.179l99.707 99.671-99.695 99.671c-4.752 4.74-4.752 12.439 0 17.191 4.752 4.74 12.463 4.74 17.215 0l108.3-108.26c4.68-4.691 4.68-12.511-0.012-17.19z"></svg>`,
    loadingIcon: `<?xml version="1.0" encoding="UTF-8"?><svg stroke="#fff" viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd" stroke-width="2"><circle cx="22" cy="22" r="1"><animate attributeName="r" begin="0s" calcMode="spline" dur="1.8s" keySplines="0.165, 0.84, 0.44, 1" keyTimes="0; 1" repeatCount="indefinite" values="1; 20"/><animate attributeName="stroke-opacity" begin="0s" calcMode="spline" dur="1.8s" keySplines="0.3, 0.61, 0.355, 1" keyTimes="0; 1" repeatCount="indefinite" values="1; 0"/></circle><circle cx="22" cy="22" r="1"><animate attributeName="r" begin="-0.9s" calcMode="spline" dur="1.8s" keySplines="0.165, 0.84, 0.44, 1" keyTimes="0; 1" repeatCount="indefinite" values="1; 20"/><animate attributeName="stroke-opacity" begin="-0.9s" calcMode="spline" dur="1.8s" keySplines="0.3, 0.61, 0.355, 1" keyTimes="0; 1" repeatCount="indefinite" values="1; 0"/></circle></g></svg>`
};

class ImageItem {
    constructor(data) {
        this.data = data;
        this.type = GalleryItemTypes.Image;
    }
}
class VideoItem {
    constructor(data) {
        this.data = data;
        this.type = GalleryItemTypes.Video;
    }
}
class IframeItem {
    constructor(data) {
        this.data = data;
        this.type = GalleryItemTypes.Iframe;
    }
}
class YoutubeItem {
    constructor(data) {
        this.data = {
            ...data,
            ...{
                src: `https://youtube.com/embed/${data.src}`,
                thumb: data.thumb ? data.thumb : `//img.youtube.com/vi/${data.src}/default.jpg`
            }
        };
        this.type = GalleryItemTypes.Youtube;
    }
}
class VimeoItem {
    constructor(data) {
        this.data = {
            ...data,
            ...{
                src: `https://player.vimeo.com/video/${data.src}`,
                thumb: data.thumb ? data.thumb : this.getVimeoThumb(data.src)
            }
        };
        this.type = GalleryItemTypes.Vimeo;
    }
    getVimeoThumb(videoId) {
        //Vimeo has no API for getting a thumbnail, but this project can do it: https://github.com/ThatGuySam/vumbnail
        return `//vumbnail.com/${videoId}.jpg`;
    }
}

const filterActions = (actions) => {
    return filter((state) => actions.indexOf(state.action) > -1);
};
class GalleryRef {
    get stateSnapshot() {
        return this._state.value;
    }
    get configSnapshot() {
        return this._config.value;
    }
    /** Stream that emits when gallery is initialized/reset */
    get initialized() {
        return this.state.pipe(filterActions([GalleryAction.INITIALIZED]));
    }
    /** Stream that emits when items is changed (items loaded, item added, item removed) */
    get itemsChanged() {
        return this.state.pipe(filterActions([GalleryAction.ITEMS_CHANGED]));
    }
    /** Stream that emits when current item is changed */
    get indexChanged() {
        return this.state.pipe(filterActions([GalleryAction.INDEX_CHANGED]));
    }
    /** Stream that emits when the player should start or stop */
    get playingChanged() {
        return this.state.pipe(filterActions([GalleryAction.PLAY, GalleryAction.STOP]));
    }
    constructor(config, deleteInstance) {
        this.deleteInstance = deleteInstance;
        /** Stream that emits on item click */
        this.itemClick = new Subject();
        /** Stream that emits on thumbnail click */
        this.thumbClick = new Subject();
        /** Stream that emits on an error occurs */
        this.error = new Subject();
        this._state = new BehaviorSubject(defaultState);
        this._config = new BehaviorSubject(config);
        this.state = this._state.asObservable();
        this.config = this._config.asObservable();
    }
    /**
     * Set gallery state
     */
    setState(state) {
        this._state.next({ ...this.stateSnapshot, ...state });
    }
    /**
     * Set gallery config
     */
    setConfig(config) {
        this._config.next({ ...this._config.value, ...config });
    }
    /**
     * Add gallery item
     */
    add(item, active) {
        const items = [...this.stateSnapshot.items, item];
        this.setState({
            action: GalleryAction.ITEMS_CHANGED,
            items,
            hasNext: items.length > 1,
            currIndex: active ? items.length - 1 : this.stateSnapshot.currIndex
        });
    }
    /**
     * Add image item
     */
    addImage(data, active) {
        this.add(new ImageItem(data), active);
    }
    /**
     * Add video item
     */
    addVideo(data, active) {
        this.add(new VideoItem(data), active);
    }
    /**
     * Add iframe item
     */
    addIframe(data, active) {
        this.add(new IframeItem(data), active);
    }
    /**
     * Add Youtube item
     */
    addYoutube(data, active) {
        this.add(new YoutubeItem(data), active);
    }
    /**
     * Add Vimeo item
     */
    addVimeo(data, active) {
        this.add(new VimeoItem(data), active);
    }
    /**
     * Remove gallery item
     */
    remove(i) {
        const state = this.stateSnapshot;
        const items = [
            ...state.items.slice(0, i),
            ...state.items.slice(i + 1, state.items.length)
        ];
        this.setState({
            action: GalleryAction.ITEMS_CHANGED,
            currIndex: i < 1 ? state.currIndex : i - 1,
            items,
            hasNext: items.length > 1,
            hasPrev: i > 0
        });
    }
    /**
     * Load items and reset the state
     */
    load(items) {
        if (items) {
            this.setState({
                action: GalleryAction.ITEMS_CHANGED,
                items,
                hasNext: items.length > 1,
                hasPrev: false
            });
        }
    }
    /**
     * Set active item
     */
    set(i, behavior = this._config.value.scrollBehavior) {
        if (i < 0 || i >= this.stateSnapshot.items.length) {
            console.error(`[NgGallery]: Unable to set the active item because the given index (${i}) is outside the items range!`);
            return;
        }
        if (i !== this.stateSnapshot.currIndex) {
            this.setState({
                behavior,
                action: GalleryAction.INDEX_CHANGED,
                currIndex: i,
                hasNext: i < this.stateSnapshot.items.length - 1,
                hasPrev: i > 0
            });
        }
    }
    /**
     * Next item
     */
    next(behavior = this._config.value.scrollBehavior, loop = true) {
        if (this.stateSnapshot.hasNext) {
            this.set(this.stateSnapshot.currIndex + 1, behavior);
        }
        else if (loop && this._config.value.loop) {
            this.set(0, behavior);
        }
    }
    /**
     * Prev item
     */
    prev(behavior = this._config.value.scrollBehavior, loop = true) {
        if (this.stateSnapshot.hasPrev) {
            this.set(this.stateSnapshot.currIndex - 1, behavior);
        }
        else if (loop && this._config.value.loop) {
            this.set(this.stateSnapshot.items.length - 1, behavior);
        }
    }
    /**
     * Start gallery player
     */
    play(interval) {
        if (interval) {
            this.setConfig({ autoplayInterval: interval });
        }
        this.setState({ action: GalleryAction.PLAY, behavior: 'auto', isPlaying: true });
    }
    /**
     * Stop gallery player
     */
    stop() {
        this.setState({ action: GalleryAction.STOP, isPlaying: false });
    }
    /**
     * Reset gallery to initial state
     */
    reset() {
        this.setState(defaultState);
    }
    /**
     * Destroy gallery
     */
    destroy() {
        this._state.complete();
        this._config.complete();
        this.itemClick.complete();
        this.thumbClick.complete();
        this.deleteInstance();
    }
}

const GALLERY_CONFIG = new InjectionToken('GALLERY_CONFIG');

class Gallery {
    constructor(config) {
        /** Store gallery instances */
        this._instances = new Map();
        this.config = config ? { ...defaultConfig, ...config } : defaultConfig;
    }
    /**
     * Get or create gallery by ID
     * @param id
     * @param config
     */
    ref(id = 'root', config) {
        if (this._instances.has(id)) {
            const galleryRef = this._instances.get(id);
            if (config) {
                galleryRef.setConfig(config);
            }
            return galleryRef;
        }
        else {
            return this._instances.set(id, new GalleryRef({ ...this.config, ...config }, this.deleteInstance(id))).get(id);
        }
    }
    /**
     * Destroy all gallery instances
     */
    destroyAll() {
        this._instances.forEach((ref) => ref.destroy());
    }
    /**
     * Reset all gallery instances
     */
    resetAll() {
        this._instances.forEach((ref) => ref.reset());
    }
    /**
     * Logger for debugging
     */
    debugConsole(...data) {
        if (this.config.debug) {
            console.log(...data);
        }
    }
    /**
     * A destroyer function for each gallery instance
     */
    deleteInstance(id) {
        return () => {
            if (this._instances.has(id)) {
                this._instances.delete(id);
            }
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: Gallery, deps: [{ token: GALLERY_CONFIG, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: Gallery, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: Gallery, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [GALLERY_CONFIG]
                }] }] });

class GalleryCounterComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryCounterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.1", type: GalleryCounterComponent, isStandalone: true, selector: "gallery-counter", inputs: { state: "state" }, ngImport: i0, template: `
    <div class="g-counter">{{ (state.currIndex + 1) + ' / ' + state.items.length }}</div>
  `, isInline: true, styles: [".g-counter{font-weight:700;-webkit-user-select:none;user-select:none;opacity:.6;transition:opacity linear .15s;z-index:50;position:absolute;left:50%;transform:translate(-50%) perspective(1px);font-size:12px;padding:4px 10px;color:var(--g-font-color);background-color:var(--g-overlay-color);box-shadow:var(--g-box-shadow);top:var(--counter-top);bottom:var(--counter-bottom);border-radius:var(--counter-border-radius)}.g-counter:hover{opacity:.8}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryCounterComponent, decorators: [{
            type: Component,
            args: [{ selector: 'gallery-counter', changeDetection: ChangeDetectionStrategy.OnPush, template: `
    <div class="g-counter">{{ (state.currIndex + 1) + ' / ' + state.items.length }}</div>
  `, standalone: true, styles: [".g-counter{font-weight:700;-webkit-user-select:none;user-select:none;opacity:.6;transition:opacity linear .15s;z-index:50;position:absolute;left:50%;transform:translate(-50%) perspective(1px);font-size:12px;padding:4px 10px;color:var(--g-font-color);background-color:var(--g-overlay-color);box-shadow:var(--g-box-shadow);top:var(--counter-top);bottom:var(--counter-bottom);border-radius:var(--counter-border-radius)}.g-counter:hover{opacity:.8}\n"] }]
        }], propDecorators: { state: [{
                type: Input
            }] } });

class GalleryBulletsComponent {
    constructor(gallery) {
        this.gallery = gallery;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryBulletsComponent, deps: [{ token: Gallery }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.1", type: GalleryBulletsComponent, isStandalone: true, selector: "gallery-bullets", inputs: { galleryId: "galleryId", state: "state", config: "config" }, ngImport: i0, template: `
    <div class="g-bullet"
         *ngFor="let item of state.items; let i = index"
         [class.g-bullet-active]="i === state.currIndex"
         [style.width.px]="config?.bulletSize"
         [style.height.px]="config?.bulletSize"
         (click)="config.disableBullets ? null : gallery.ref(this.galleryId).set(i)">
      <div class="g-bullet-inner"></div>
    </div>
  `, isInline: true, styles: [":host{position:absolute;left:50%;z-index:99;transform:translate(-50%);display:flex;gap:6px;top:var(--bullets-top);bottom:var(--bullets-bottom)}:host,.g-bullet,.g-bullet-inner{display:flex;justify-content:center;align-items:center}.g-bullet{cursor:var(--bullets-cursor);z-index:20}.g-bullet:hover .g-bullet-inner{opacity:var(--bullets-hover-opacity)}.g-bullet-active .g-bullet-inner{opacity:var(--bullets-active-opacity)}.g-bullet-inner{background-color:var(--g-overlay-color);opacity:var(--bullets-opacity);width:100%;height:100%;border-radius:50%;transition:opacity linear .15s}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryBulletsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'gallery-bullets', changeDetection: ChangeDetectionStrategy.OnPush, template: `
    <div class="g-bullet"
         *ngFor="let item of state.items; let i = index"
         [class.g-bullet-active]="i === state.currIndex"
         [style.width.px]="config?.bulletSize"
         [style.height.px]="config?.bulletSize"
         (click)="config.disableBullets ? null : gallery.ref(this.galleryId).set(i)">
      <div class="g-bullet-inner"></div>
    </div>
  `, standalone: true, imports: [CommonModule], styles: [":host{position:absolute;left:50%;z-index:99;transform:translate(-50%);display:flex;gap:6px;top:var(--bullets-top);bottom:var(--bullets-bottom)}:host,.g-bullet,.g-bullet-inner{display:flex;justify-content:center;align-items:center}.g-bullet{cursor:var(--bullets-cursor);z-index:20}.g-bullet:hover .g-bullet-inner{opacity:var(--bullets-hover-opacity)}.g-bullet-active .g-bullet-inner{opacity:var(--bullets-active-opacity)}.g-bullet-inner{background-color:var(--g-overlay-color);opacity:var(--bullets-opacity);width:100%;height:100%;border-radius:50%;transition:opacity linear .15s}\n"] }]
        }], ctorParameters: () => [{ type: Gallery }], propDecorators: { galleryId: [{
                type: Input
            }], state: [{
                type: Input
            }], config: [{
                type: Input
            }] } });

class GalleryNavComponent {
    constructor(gallery, _sanitizer, dir) {
        this.gallery = gallery;
        this._sanitizer = _sanitizer;
        this.dir = dir;
    }
    ngOnInit() {
        this.navIcon = this._sanitizer.bypassSecurityTrustHtml(this.config.navIcon);
    }
    rightButton() {
    }
    leftButton() {
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryNavComponent, deps: [{ token: Gallery }, { token: i1$1.DomSanitizer }, { token: i1$2.Directionality }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.1", type: GalleryNavComponent, isStandalone: true, selector: "gallery-nav", inputs: { id: ["galleryId", "id"], state: "state", config: "config" }, ngImport: i0, template: `
    <i *ngIf="config.loop || state.hasPrev"
       class="g-nav-prev"
       aria-label="Previous"
       role="button"
       (click)="gallery.ref(this.id).prev(config.scrollBehavior)"
       [innerHtml]="navIcon"></i>

    <i *ngIf="config.loop || state.hasNext"
       class="g-nav-next"
       aria-label="Next"
       role="button"
       (click)="gallery.ref(this.id).next(config.scrollBehavior)"
       [innerHtml]="navIcon"></i>
  `, isInline: true, styles: [".g-nav-next,.g-nav-prev{position:absolute;top:50%;display:flex;padding:16px 8px;cursor:pointer;z-index:999;opacity:.6;transition:opacity linear .15s,right linear .15s,left linear .15s}.g-nav-next:hover,.g-nav-prev:hover{opacity:1}.g-nav-next ::ng-deep svg,.g-nav-prev ::ng-deep svg{filter:var(--g-nav-drop-shadow);width:28px;height:28px;fill:#fff}.g-nav-next{left:var(--nav-next-left);right:var(--nav-next-right);transform:var(--nav-next-transform)}.g-nav-next:hover{left:var(--nav-next-hover-left);right:var(--nav-next-hover-right)}.g-nav-prev{left:var(--nav-prev-left);right:var(--nav-prev-right);transform:var(--nav-prev-transform)}.g-nav-prev:hover{left:var(--nav-prev-hover-left);right:var(--nav-prev-hover-right)}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryNavComponent, decorators: [{
            type: Component,
            args: [{ selector: 'gallery-nav', changeDetection: ChangeDetectionStrategy.OnPush, template: `
    <i *ngIf="config.loop || state.hasPrev"
       class="g-nav-prev"
       aria-label="Previous"
       role="button"
       (click)="gallery.ref(this.id).prev(config.scrollBehavior)"
       [innerHtml]="navIcon"></i>

    <i *ngIf="config.loop || state.hasNext"
       class="g-nav-next"
       aria-label="Next"
       role="button"
       (click)="gallery.ref(this.id).next(config.scrollBehavior)"
       [innerHtml]="navIcon"></i>
  `, standalone: true, imports: [CommonModule], styles: [".g-nav-next,.g-nav-prev{position:absolute;top:50%;display:flex;padding:16px 8px;cursor:pointer;z-index:999;opacity:.6;transition:opacity linear .15s,right linear .15s,left linear .15s}.g-nav-next:hover,.g-nav-prev:hover{opacity:1}.g-nav-next ::ng-deep svg,.g-nav-prev ::ng-deep svg{filter:var(--g-nav-drop-shadow);width:28px;height:28px;fill:#fff}.g-nav-next{left:var(--nav-next-left);right:var(--nav-next-right);transform:var(--nav-next-transform)}.g-nav-next:hover{left:var(--nav-next-hover-left);right:var(--nav-next-hover-right)}.g-nav-prev{left:var(--nav-prev-left);right:var(--nav-prev-right);transform:var(--nav-prev-transform)}.g-nav-prev:hover{left:var(--nav-prev-hover-left);right:var(--nav-prev-hover-right)}\n"] }]
        }], ctorParameters: () => [{ type: Gallery }, { type: i1$1.DomSanitizer }, { type: i1$2.Directionality }], propDecorators: { id: [{
                type: Input,
                args: ['galleryId']
            }], state: [{
                type: Input
            }], config: [{
                type: Input
            }] } });

/**
 * A clone of HammerJs constants
 */
const DIRECTION_LEFT = 2;
const DIRECTION_RIGHT = 4;
const DIRECTION_UP = 8;
const DIRECTION_DOWN = 16;
class HorizontalAdapter {
    get scrollValue() {
        return this.slider.scrollLeft;
    }
    get clientSize() {
        return this.slider.clientWidth;
    }
    get isContentLessThanContainer() {
        return this.clientSize >= this.slider.firstElementChild.clientWidth;
    }
    constructor(slider, config) {
        this.slider = slider;
        this.config = config;
        this.hammerDirection = DIRECTION_LEFT | DIRECTION_RIGHT;
        this.scrollSnapType = 'x mandatory';
    }
    getScrollToValue(el, behavior) {
        const position = el.offsetLeft - ((this.clientSize - el.clientWidth) / 2);
        return {
            behavior,
            start: position
        };
    }
    getRootMargin() {
        return `1000px 1px 1000px 1px`;
    }
    getElementRootMargin(viewport, el) {
        const rootMargin = -1 * ((viewport.clientWidth - el.clientWidth) / 2) + 1;
        return `0px ${rootMargin}px 0px ${rootMargin}px`;
    }
    getCentralizerStartSize() {
        if (this.isContentLessThanContainer) {
            const size = this.clientSize - this.slider.firstElementChild.clientWidth;
            return size / 2;
        }
        return (this.clientSize / 2) - (this.slider.firstElementChild.firstElementChild?.clientWidth / 2);
    }
    getCentralizerEndSize() {
        if (this.isContentLessThanContainer) {
            const size = this.clientSize - this.slider.firstElementChild.clientWidth;
            return size / 2;
        }
        return (this.clientSize / 2) - (this.slider.firstElementChild.lastElementChild?.clientWidth / 2);
    }
    getHammerVelocity(e) {
        return e.velocityX;
    }
    getHammerValue(value, e, behavior) {
        return {
            behavior,
            left: value - e.deltaX
        };
    }
}
class VerticalAdapter {
    get scrollValue() {
        return this.slider.scrollTop;
    }
    get clientSize() {
        return this.slider.clientHeight;
    }
    get isContentLessThanContainer() {
        return this.clientSize >= this.slider.firstElementChild.clientHeight;
    }
    constructor(slider, config) {
        this.slider = slider;
        this.config = config;
        this.hammerDirection = DIRECTION_UP | DIRECTION_DOWN;
        this.scrollSnapType = 'y mandatory';
    }
    getScrollToValue(el, behavior) {
        const position = el.offsetTop - ((this.clientSize - el.clientHeight) / 2);
        return {
            behavior,
            top: position
        };
    }
    getRootMargin() {
        return `1px 1000px 1px 1000px`;
    }
    getElementRootMargin(viewport, el) {
        const rootMargin = -1 * ((viewport.clientHeight - el.clientHeight) / 2) + 1;
        return `${rootMargin}px 0px ${rootMargin}px 0px`;
    }
    getCentralizerStartSize() {
        if (this.isContentLessThanContainer) {
            const size = this.clientSize - this.slider.firstElementChild.clientHeight;
            return size / 2;
        }
        return (this.clientSize / 2) - (this.slider.firstElementChild.firstElementChild?.clientHeight / 2);
    }
    getCentralizerEndSize() {
        if (this.isContentLessThanContainer) {
            const size = this.clientSize - this.slider.firstElementChild.clientHeight;
            return size / 2;
        }
        return (this.clientSize / 2) - (this.slider.firstElementChild.lastElementChild?.clientHeight / 2);
    }
    getHammerVelocity(e) {
        return e.velocityY;
    }
    getHammerValue(value, e, behavior) {
        return {
            behavior,
            top: value - e.deltaY
        };
    }
}

class SliderAdapter {
}

/**
 * https://github.com/gre/bezier-easing
 * BezierEasing - use bezier curve for transition easing function
 * by Gaëtan Renaudeau 2014 - 2015 – MIT License
 */
// These values are established by empiricism with tests (tradeoff: performance VS precision)
const NEWTON_ITERATIONS = 4;
const NEWTON_MIN_SLOPE = 0.001;
const SUBDIVISION_PRECISION = 0.0000001;
const SUBDIVISION_MAX_ITERATIONS = 10;
const kSplineTableSize = 11;
const kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
const float32ArraySupported = typeof Float32Array === 'function';
function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
}
function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
}
function C(aA1) {
    return 3.0 * aA1;
}
// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
}
// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
}
function binarySubdivide(aX, aA, aB, mX1, mX2) {
    let currentX, currentT, i = 0;
    do {
        currentT = aA + (aB - aA) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0.0) {
            aB = currentT;
        }
        else {
            aA = currentT;
        }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
    return currentT;
}
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (let i = 0; i < NEWTON_ITERATIONS; ++i) {
        let currentSlope = getSlope(aGuessT, mX1, mX2);
        if (currentSlope === 0.0) {
            return aGuessT;
        }
        let currentX = calcBezier(aGuessT, mX1, mX2) - aX;
        aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
}
function LinearEasing(x) {
    return x;
}
function bezier(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
        throw new Error('bezier x values must be in [0, 1] range');
    }
    if (mX1 === mY1 && mX2 === mY2) {
        return LinearEasing;
    }
    // Precompute samples table
    let sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
    for (let i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
    function getTForX(aX) {
        let intervalStart = 0.0;
        let currentSample = 1;
        let lastSample = kSplineTableSize - 1;
        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += kSampleStepSize;
        }
        --currentSample;
        // Interpolate to provide an initial guess for t
        let dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        let guessForT = intervalStart + dist * kSampleStepSize;
        let initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        }
        else if (initialSlope === 0.0) {
            return guessForT;
        }
        else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
    }
    return function BezierEasing(x) {
        // Because JavaScript number are imprecise, we should guarantee the extremes are right.
        if (x === 0) {
            return 0;
        }
        if (x === 1) {
            return 1;
        }
        return calcBezier(getTForX(x), mY1, mY2);
    };
}
;

class SmoothScroll {
    get _w() {
        return this._document.defaultView;
    }
    /**
     * Timing method
     */
    get _now() {
        return this._w.performance?.now?.bind(this._w.performance) || Date.now;
    }
    set smoothScroll(value) {
        if (value) {
            this._zone.runOutsideAngular(() => {
                this.scrollTo(value);
            });
        }
    }
    constructor(_document, _zone, _dir, _el) {
        this._document = _document;
        this._zone = _zone;
        this._dir = _dir;
        this._scrollController = new Subject();
        this._finished = new Subject();
        this.isScrollingChange = new EventEmitter();
        this._el = _el.nativeElement;
    }
    ngOnInit() {
        this._subscription = this._scrollController.pipe(switchMap((context) => {
            this._zone.run(() => {
                this.isScrollingChange.emit(true);
            });
            this._el.classList.add('g-scrolling');
            this._el.style.setProperty('--slider-scroll-snap-type', 'none');
            // Scroll each step recursively
            return of(null).pipe(expand(() => this._step(context).pipe(takeWhile((currContext) => this._isFinished(currContext)), takeUntil(this._finished))), finalize(() => this.resetElement()), takeUntil(this._interrupted()));
        })).subscribe();
    }
    ngOnDestroy() {
        this._subscription?.unsubscribe();
        this._scrollController.complete();
    }
    /**
     * changes scroll position inside an element
     */
    _scrollElement(x, y) {
        this._el.scrollLeft = x;
        this._el.scrollTop = y;
    }
    resetElement() {
        this._zone.run(() => {
            this.isScrollingChange.emit(false);
        });
        this._el.classList.remove('g-scrolling');
        if (!this._isInterruptedByMouse) {
            this._el.style.setProperty('--slider-scroll-snap-type', this.adapter.scrollSnapType);
        }
        this._isInterruptedByMouse = false;
    }
    /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     */
    _isFinished(context) {
        if (context.currentX !== context.x || context.currentY !== context.y) {
            return true;
        }
        this._finished.next();
        return false;
    }
    /**
     * Terminates an ongoing smooth scroll
     */
    _interrupted() {
        let interrupt$;
        if (this.interruptOnMousemove && typeof Hammer !== 'undefined') {
            this._hammer = new Hammer(this._el, { inputClass: Hammer.MouseInput });
            this._hammer.get('pan').set({ direction: this.adapter.hammerDirection });
            // For gallery thumb slider, dragging thumbnails should cancel the ongoing scroll
            interrupt$ = merge(new Observable((subscriber) => {
                this._hammer.on('panstart', () => {
                    this._isInterruptedByMouse = true;
                    subscriber.next();
                    subscriber.complete();
                });
                return () => {
                    this._hammer.destroy();
                };
            }), fromEvent(this._el, 'wheel', { passive: true, capture: true }), fromEvent(this._el, 'touchmove', { passive: true, capture: true }));
        }
        else {
            interrupt$ = merge(fromEvent(this._el, 'wheel', { passive: true, capture: true }), fromEvent(this._el, 'touchmove', { passive: true, capture: true }));
        }
        return interrupt$.pipe(take(1));
    }
    /**
     * A function called recursively that, given a context, steps through scrolling
     */
    _step(context) {
        return new Observable((subscriber) => {
            let elapsed = (this._now() - context.startTime) / context.duration;
            // avoid elapsed times higher than one
            elapsed = elapsed > 1 ? 1 : elapsed;
            // apply easing to elapsed time
            const value = context.easing(elapsed);
            context.currentX = context.startX + (context.x - context.startX) * value;
            context.currentY = context.startY + (context.y - context.startY) * value;
            this._scrollElement(context.currentX, context.currentY);
            // Proceed to the step
            requestAnimationFrame(() => {
                subscriber.next(context);
                subscriber.complete();
            });
        });
    }
    _applyScrollToOptions(options) {
        if (!options.duration) {
            this._scrollElement(options.left, options.top);
        }
        const context = {
            scrollable: this._el,
            startTime: this._now(),
            startX: this._el.scrollLeft,
            startY: this._el.scrollTop,
            x: options.left == null ? this._el.scrollLeft : ~~options.left,
            y: options.top == null ? this._el.scrollTop : ~~options.top,
            duration: options.duration,
            easing: bezier(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)
        };
        this._scrollController.next(context);
    }
    /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param params specified the offsets to scroll to.
     */
    scrollTo(params) {
        const isRtl = this._dir.value === 'rtl';
        const rtlScrollAxisType = getRtlScrollAxisType();
        const options = {
            ...params,
            ...{
                // Rewrite start & end offsets as right or left offsets.
                left: params.left == null ? (isRtl ? params.end : params.start) : params.left,
                right: params.right == null ? (isRtl ? params.start : params.end) : params.right
            },
            duration: params.behavior === 'smooth' ? this.config.scrollDuration : 0,
            easing: this.config.scrollEase,
        };
        // Rewrite the bottom offset as a top offset.
        if (options.bottom != null) {
            options.top = this._el.scrollHeight - this._el.clientHeight - options.bottom;
        }
        // Rewrite the right offset as a left offset.
        if (isRtl && rtlScrollAxisType !== RtlScrollAxisType.NORMAL) {
            if (options.left != null) {
                options.right = this._el.scrollWidth - this._el.clientWidth - options.left;
            }
            if (rtlScrollAxisType === RtlScrollAxisType.INVERTED) {
                options.left = options.right;
            }
            else if (rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
                options.left = options.right ? -options.right : options.right;
            }
        }
        else {
            if (options.right != null) {
                options.left = this._el.scrollWidth - this._el.clientWidth - options.right;
            }
        }
        return this._applyScrollToOptions(options);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: SmoothScroll, deps: [{ token: DOCUMENT }, { token: i0.NgZone }, { token: i1$2.Dir }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.1", type: SmoothScroll, isStandalone: true, selector: "[smoothScroll]", inputs: { smoothScroll: "smoothScroll", adapter: "adapter", config: "config", interruptOnMousemove: ["smoothScrollInterruptOnMousemove", "interruptOnMousemove"] }, outputs: { isScrollingChange: "isScrollingChange" }, providers: [Dir], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: SmoothScroll, decorators: [{
            type: Directive,
            args: [{
                    selector: '[smoothScroll]',
                    standalone: true,
                    providers: [Dir]
                }]
        }], ctorParameters: () => [{ type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.NgZone }, { type: i1$2.Dir }, { type: i0.ElementRef }], propDecorators: { smoothScroll: [{
                type: Input
            }], adapter: [{
                type: Input
            }], config: [{
                type: Input
            }], interruptOnMousemove: [{
                type: Input,
                args: ['smoothScrollInterruptOnMousemove']
            }], isScrollingChange: [{
                type: Output
            }] } });

class HammerSliding {
    get _viewport() {
        return this._el.nativeElement;
    }
    constructor(_document, _el, _dir, _platform, _zone) {
        this._document = _document;
        this._el = _el;
        this._dir = _dir;
        this._platform = _platform;
        this._zone = _zone;
        this.activeIndexChange = new EventEmitter();
        this.isSlidingChange = new EventEmitter();
    }
    ngOnChanges(changes) {
        if (changes.enabled && changes.enabled?.currentValue !== changes.enabled?.previousValue) {
            this.enabled ? this._subscribe() : this._unsubscribe();
        }
        if (!changes.adapter?.firstChange && changes.adapter?.currentValue !== changes.adapter?.previousValue) {
            this.enabled ? this._subscribe() : this._unsubscribe();
        }
    }
    ngOnDestroy() {
        this._unsubscribe();
    }
    _subscribe() {
        this._unsubscribe();
        if (!this._platform.ANDROID && !this._platform.IOS && typeof Hammer !== 'undefined') {
            this._zone.runOutsideAngular(() => {
                const direction = this.adapter.hammerDirection;
                this._hammer = new Hammer(this._el.nativeElement, { inputClass: Hammer.MouseInput });
                this._hammer.get('pan').set({ direction });
                let offset;
                // Set panOffset for sliding on pan start event
                this._hammer.on('panstart', () => {
                    this._zone.run(() => {
                        this.isSlidingChange.emit(true);
                    });
                    offset = this.adapter.scrollValue;
                    this._viewport.classList.add('g-sliding');
                    this._viewport.style.setProperty('--slider-scroll-snap-type', 'none');
                });
                this._hammer.on('panmove', (e) => this._viewport.scrollTo(this.adapter.getHammerValue(offset, e, 'auto')));
                this._hammer.on('panend', (e) => {
                    this._document.onselectstart = null;
                    this._viewport.classList.remove('g-sliding');
                    const index = this.getIndexOnMouseUp(e);
                    this._zone.run(() => {
                        this.isSlidingChange.emit(false);
                        this.activeIndexChange.emit(index);
                    });
                });
            });
        }
    }
    _unsubscribe() {
        this._hammer?.destroy();
    }
    getIndexOnMouseUp(e) {
        // Check if scrolled item is great enough to navigate
        const currElement = this.items[this.state.currIndex].nativeElement;
        // Find the gallery item element in the center elements
        const elementAtCenter = this.getElementFromViewportCenter();
        // Check if center item can be taken from element using
        if (elementAtCenter && elementAtCenter !== currElement) {
            return +elementAtCenter.getAttribute('galleryIndex');
        }
        const velocity = this.adapter.getHammerVelocity(e);
        // Check if velocity is great enough to navigate
        if (Math.abs(velocity) > 0.3) {
            if (this.config.orientation === Orientation.Horizontal) {
                if (velocity > 0) {
                    return this._dir.value === 'rtl' ? this.state.currIndex + 1 : this.state.currIndex - 1;
                }
                return this._dir.value === 'rtl' ? this.state.currIndex - 1 : this.state.currIndex + 1;
            }
            else {
                return velocity > 0 ? this.state.currIndex - 1 : this.state.currIndex + 1;
            }
        }
        // Reset position to the current index
        return -1;
    }
    getElementFromViewportCenter() {
        // Get slider position relative to the document
        const sliderRect = this._viewport.getBoundingClientRect();
        // Try look for the center item using `elementsFromPoint` function
        const centerElements = this._document.elementsFromPoint(sliderRect.x + (sliderRect.width / 2), sliderRect.y + (sliderRect.height / 2));
        // Find the gallery item element in the center elements
        return centerElements.find((element) => {
            return element.getAttribute('galleryId') === this.galleryId;
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: HammerSliding, deps: [{ token: DOCUMENT }, { token: i0.ElementRef }, { token: i1$2.Directionality }, { token: i2.Platform }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.1", type: HammerSliding, isStandalone: true, selector: "[hammerSliding]", inputs: { enabled: ["hammerSliding", "enabled"], galleryId: "galleryId", items: "items", adapter: "adapter", state: "state", config: "config" }, outputs: { activeIndexChange: "activeIndexChange", isSlidingChange: "isSlidingChange" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: HammerSliding, decorators: [{
            type: Directive,
            args: [{
                    selector: '[hammerSliding]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.ElementRef }, { type: i1$2.Directionality }, { type: i2.Platform }, { type: i0.NgZone }], propDecorators: { enabled: [{
                type: Input,
                args: ['hammerSliding']
            }], galleryId: [{
                type: Input
            }], items: [{
                type: Input
            }], adapter: [{
                type: Input
            }], state: [{
                type: Input
            }], config: [{
                type: Input
            }], activeIndexChange: [{
                type: Output
            }], isSlidingChange: [{
                type: Output
            }] } });

class ActiveItemObserver {
    observe(root, elements, rootMargin) {
        return createIntersectionObserver(root, elements, rootMargin).pipe(map((entry) => {
            if (entry.isIntersecting) {
                entry.target.classList.add('g-item-highlight');
                return +entry.target.getAttribute('galleryIndex');
            }
            else {
                entry.target.classList.remove('g-item-highlight');
                return -1;
            }
        }), filter((index) => index !== -1));
    }
}
function createIntersectionObserver(root, elements, rootMargin) {
    return new Observable((observer) => {
        const intersectionObserver = new IntersectionObserver((entries) => observer.next(entries), {
            root,
            rootMargin,
            threshold: 1
        });
        elements.forEach((element) => intersectionObserver.observe(element));
        return () => {
            elements.forEach((element) => intersectionObserver.unobserve(element));
            intersectionObserver.disconnect();
        };
    }).pipe(mergeMap((entries) => entries));
}

class SliderIntersectionObserver {
    get _viewport() {
        return this._el.nativeElement;
    }
    constructor(_zone, _el) {
        this._zone = _zone;
        this._el = _el;
        this._sensor = new ActiveItemObserver();
        this.activeIndexChange = new EventEmitter();
    }
    ngOnChanges() {
        (this.config.itemAutosize || this.disabled) ? this._unsubscribe() : this._subscribe();
    }
    ngOnDestroy() {
        this._unsubscribe();
    }
    _subscribe() {
        this._unsubscribe();
        if (!!this.adapter && !!this.items?.length) {
            const rootMargin = this.adapter.getRootMargin();
            if (this.config.debug) {
                this._viewport.style.setProperty('--intersection-margin', `"INTERSECTION(${rootMargin})"`);
            }
            this._zone.runOutsideAngular(() => {
                this._currentSubscription = this._sensor.observe(this._viewport, this.items.map((item) => item.nativeElement), rootMargin).subscribe((index) => {
                    this._zone.run(() => this.activeIndexChange.emit(index));
                });
            });
        }
    }
    _unsubscribe() {
        this._currentSubscription?.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: SliderIntersectionObserver, deps: [{ token: i0.NgZone }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.1", type: SliderIntersectionObserver, isStandalone: true, selector: "[sliderIntersectionObserver]", inputs: { adapter: "adapter", items: "items", config: "config", disabled: ["sliderIntersectionObserverDisabled", "disabled"] }, outputs: { activeIndexChange: "activeIndexChange" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: SliderIntersectionObserver, decorators: [{
            type: Directive,
            args: [{
                    selector: '[sliderIntersectionObserver]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: i0.ElementRef }], propDecorators: { adapter: [{
                type: Input
            }], items: [{
                type: Input
            }], config: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: ['sliderIntersectionObserverDisabled']
            }], activeIndexChange: [{
                type: Output
            }] } });

function resizeObservable(el, setter) {
    return new Observable((subscriber) => {
        const resizeObserver = new ResizeObserver((entries) => subscriber.next(entries));
        resizeObserver.observe(el);
        if (setter) {
            setter(resizeObserver);
        }
        return () => resizeObserver.disconnect();
    }).pipe(mergeMap((entries) => entries));
}

class GalleryIframeComponent {
    set src(src) {
        this.videoSrc = src;
        this.iframeSrc = this._sanitizer.bypassSecurityTrustResourceUrl(src);
    }
    set pauseVideo(shouldPause) {
        if (this.iframe?.nativeElement) {
            if (shouldPause) {
                const iframe = this.iframe.nativeElement;
                iframe.src = null;
                if (!this.autoplay && this.videoSrc) {
                    this.iframeSrc = this._sanitizer.bypassSecurityTrustResourceUrl(this.videoSrc);
                }
            }
        }
    }
    constructor(_sanitizer) {
        this._sanitizer = _sanitizer;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryIframeComponent, deps: [{ token: i1$1.DomSanitizer }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.1", type: GalleryIframeComponent, isStandalone: true, selector: "gallery-iframe", inputs: { src: "src", pauseVideo: ["pause", "pauseVideo"], autoplay: "autoplay", loadingAttr: "loadingAttr" }, viewQueries: [{ propertyName: "iframe", first: true, predicate: ["iframe"], descendants: true }], ngImport: i0, template: `
    <iframe *ngIf="autoplay; else default"
            #iframe
            [attr.loading]="loadingAttr"
            allowfullscreen
            allow
            style="border:none"
            [src]="iframeSrc">
    </iframe>
    <ng-template #default>
      <iframe #iframe
              [attr.loading]="loadingAttr"
              allowfullscreen
              style="border:none"
              [src]="iframeSrc">
      </iframe>
    </ng-template>
  `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryIframeComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'gallery-iframe',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: `
    <iframe *ngIf="autoplay; else default"
            #iframe
            [attr.loading]="loadingAttr"
            allowfullscreen
            allow
            style="border:none"
            [src]="iframeSrc">
    </iframe>
    <ng-template #default>
      <iframe #iframe
              [attr.loading]="loadingAttr"
              allowfullscreen
              style="border:none"
              [src]="iframeSrc">
      </iframe>
    </ng-template>
  `,
                    standalone: true,
                    imports: [NgIf]
                }]
        }], ctorParameters: () => [{ type: i1$1.DomSanitizer }], propDecorators: { src: [{
                type: Input,
                args: ['src']
            }], pauseVideo: [{
                type: Input,
                args: ['pause']
            }], autoplay: [{
                type: Input
            }], loadingAttr: [{
                type: Input
            }], iframe: [{
                type: ViewChild,
                args: ['iframe']
            }] } });

class GalleryVideoComponent {
    constructor() {
        /** Stream that emits when an error occurs */
        this.error = new EventEmitter();
    }
    set pauseVideo(shouldPause) {
        if (this.video.nativeElement) {
            const video = this.video.nativeElement;
            if (shouldPause && !video.paused) {
                video.pause();
            }
        }
    }
    set playVideo(shouldPlay) {
        if (this.video.nativeElement) {
            const video = this.video.nativeElement;
            if (shouldPlay) {
                video.play();
            }
        }
    }
    ngOnInit() {
        if (this.src instanceof Array) {
            // If video has multiple sources
            this.videoSources = [...this.src];
        }
        else {
            this.videoSources = [{ url: this.src }];
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryVideoComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.1", type: GalleryVideoComponent, isStandalone: true, selector: "gallery-video", inputs: { src: "src", poster: "poster", mute: "mute", loop: "loop", controls: "controls", controlsList: "controlsList", disableRemotePlayback: "disableRemotePlayback", disablePictureInPicture: "disablePictureInPicture", pauseVideo: ["pause", "pauseVideo"], playVideo: ["play", "playVideo"] }, outputs: { error: "error" }, viewQueries: [{ propertyName: "video", first: true, predicate: ["video"], descendants: true, static: true }], ngImport: i0, template: `
    <video #video
           [attr.mute]="mute"
           [attr.controlsList]="controlsList"
           [attr.disablePictureInPicture]="disablePictureInPicture"
           [disableRemotePlayback]="disableRemotePlayback"
           [controls]="controls"
           [loop]="loop"
           [poster]="poster"
           (error)="error.emit($event)">
      <ng-container *ngFor="let src of videoSources">
        <source *ngIf="src?.type; else noType" [src]="src?.url" [type]="src.type"/>
        <ng-template #noType>
          <source [src]="src?.url"/>
        </ng-template>
      </ng-container>
    </video>
  `, isInline: true, dependencies: [{ kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryVideoComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'gallery-video',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: `
    <video #video
           [attr.mute]="mute"
           [attr.controlsList]="controlsList"
           [attr.disablePictureInPicture]="disablePictureInPicture"
           [disableRemotePlayback]="disableRemotePlayback"
           [controls]="controls"
           [loop]="loop"
           [poster]="poster"
           (error)="error.emit($event)">
      <ng-container *ngFor="let src of videoSources">
        <source *ngIf="src?.type; else noType" [src]="src?.url" [type]="src.type"/>
        <ng-template #noType>
          <source [src]="src?.url"/>
        </ng-template>
      </ng-container>
    </video>
  `,
                    standalone: true,
                    imports: [NgFor, NgIf]
                }]
        }], propDecorators: { src: [{
                type: Input
            }], poster: [{
                type: Input
            }], mute: [{
                type: Input
            }], loop: [{
                type: Input
            }], controls: [{
                type: Input
            }], controlsList: [{
                type: Input
            }], disableRemotePlayback: [{
                type: Input
            }], disablePictureInPicture: [{
                type: Input
            }], pauseVideo: [{
                type: Input,
                args: ['pause']
            }], playVideo: [{
                type: Input,
                args: ['play']
            }], error: [{
                type: Output
            }], video: [{
                type: ViewChild,
                args: ['video', { static: true }]
            }] } });

const imageFailedSvg = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="100" height="100" version="1.1" viewBox="0 0 256 256" xml:space="preserve" xmlns="http://www.w3.org/2000/svg">
 <g transform="translate(1.4066 1.4066) scale(2.81)">
\t<path d="m74.453 48.627c-5.538 0-11.075-2.107-15.291-6.324-6.11-6.11-7.768-14.99-5.024-22.629h-48.08c-3.346 1e-3 -6.058 2.713-6.058 6.059v16.322l23.834 20.315c2.278 1.942 5.573 2.119 8.047 0.434l14.382-9.801c2.33-1.588 5.408-1.531 7.677 0.141l27.15 20.001v-25.574c-2.156 0.692-4.394 1.056-6.637 1.056z" fill="#c1e5f4" stroke-linecap="round"/>
 <circle cx="27.942" cy="37.942" r="6.072" fill="#fff0a9"/>
 <path d="m85.446 16.02c-6.061-6.061-15.922-6.061-21.983 0s-6.061 15.923 0 21.984c3.031 3.031 7.011 4.546 10.992 4.546 3.98 0 7.962-1.515 10.992-4.545 2.936-2.937 4.553-6.841 4.553-10.993s-1.617-8.056-4.554-10.992zm-3.555 3.555c1.987 1.986 3.081 4.627 3.081 7.436 0 1.95-0.538 3.813-1.525 5.438l-14.428-14.428c4.043-2.442 9.384-1.934 12.872 1.554zm-14.873 14.874c-3.486-3.487-3.997-8.829-1.554-12.873l14.426 14.427c-4.043 2.443-9.385 1.932-12.872-1.554z" fill="#e29393" stroke-linecap="round"/>
 <path d="m0 40.043v32.425c0 3.346 2.712 6.058 6.058 6.058h68.974c3.346 0 6.058-2.712 6.058-6.058v-1.335l-27.15-20.001c-2.27-1.672-5.348-1.729-7.677-0.141l-14.383 9.801c-2.473 1.686-5.769 1.508-8.047-0.434l-23.833-20.315z" fill="#96ea9c" stroke-linecap="round"/>
</g>
</svg>
`;

class ImgManager {
    constructor() {
        this.trigger$ = new BehaviorSubject(null);
        this.images = new Map();
    }
    getActiveItem(state$) {
        return this.trigger$.pipe(switchMap(() => state$.pipe(switchMap((state) => {
            const img = this.images.get(state.currIndex);
            if (img) {
                return img.state.pipe(filter((state) => state !== 'loading'), map(() => img.target));
            }
            return EMPTY;
        }))));
    }
    addItem(index, payload) {
        this.images.set(index, payload);
        this.trigger$.next();
    }
    deleteItem(index) {
        if (this.images.has(index)) {
            this.images.delete(index);
            this.trigger$.next();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: ImgManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: ImgManager }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: ImgManager, decorators: [{
            type: Injectable
        }] });

class ImgRecognizer {
    onLoad() {
        this.item.state$.next('success');
    }
    onError() {
        this.item.state$.next('failed');
    }
    constructor(el, manager, item) {
        this.el = el;
        this.manager = manager;
        this.item = item;
        if (item) {
            // Mark the gallery-item component as an image item
            item.isItemContainImage = true;
        }
        else {
            throw new Error('[NgGallery]: galleryImage directive should be only used inside gallery item templates!');
        }
    }
    ngOnInit() {
        this.manager.addItem(this.index, {
            state: this.item.state$.asObservable(),
            target: this.el.nativeElement
        });
    }
    ngOnDestroy() {
        this.manager.deleteItem(this.index);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: ImgRecognizer, deps: [{ token: i0.ElementRef }, { token: ImgManager }, { token: GalleryItemComponent }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.1", type: ImgRecognizer, isStandalone: true, selector: "img[galleryImage]", inputs: { index: ["galleryImage", "index"] }, host: { listeners: { "load": "onLoad($event)", "error": "onError($event)" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: ImgRecognizer, decorators: [{
            type: Directive,
            args: [{
                    selector: 'img[galleryImage]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: ImgManager }, { type: GalleryItemComponent }], propDecorators: { index: [{
                type: Input,
                args: ['galleryImage']
            }], onLoad: [{
                type: HostListener,
                args: ['load', ['$event']]
            }], onError: [{
                type: HostListener,
                args: ['error', ['$event']]
            }] } });

class GalleryImageComponent {
    get imageState() {
        return this.state;
    }
    constructor(_sanitizer) {
        this._sanitizer = _sanitizer;
        this.state = 'loading';
        this.errorIcon = imageFailedSvg;
        /** Stream that emits when an error occurs */
        this.error = new EventEmitter();
    }
    ngOnInit() {
        if (this.loadingIcon) {
            this.loaderTemplate = this._sanitizer.bypassSecurityTrustHtml(this.loadingIcon);
        }
        if (this.loadingError) {
            this.errorTemplate = this._sanitizer.bypassSecurityTrustHtml(this.loadingError);
        }
        if (this.errorIcon) {
            this.errorSvg = this._sanitizer.bypassSecurityTrustHtml(this.errorIcon);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryImageComponent, deps: [{ token: i1$1.DomSanitizer }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.1", type: GalleryImageComponent, isStandalone: true, selector: "gallery-image", inputs: { isThumbnail: "isThumbnail", index: "index", loadingAttr: "loadingAttr", alt: "alt", src: "src", loadingIcon: "loadingIcon", loadingError: "loadingError", errorIcon: "errorIcon" }, outputs: { error: "error" }, host: { properties: { "attr.imageState": "this.imageState" } }, ngImport: i0, template: `
    <ng-container [ngSwitch]="state">

      <ng-container *ngIf="isThumbnail; else main">
        <img [@fadeIn]="state"
             [src]="src"
             [attr.alt]="alt"
             [attr.loading]="loadingAttr"
             [style.visibility]="state === 'success' ? 'visible' : 'hidden'"
             class="g-image-item"
             (load)="state = 'success'"
             (error)="state = 'failed'; error.emit($event)"/>
      </ng-container>
      <ng-template #main>
        <img [galleryImage]="index"
             [@fadeIn]="state"
             [src]="src"
             [attr.alt]="alt"
             [attr.loading]="loadingAttr"
             [style.visibility]="state === 'success' ? 'visible' : 'hidden'"
             class="g-image-item"
             (load)="state = 'success'"
             (error)="state = 'failed'; error.emit($event)"/>
      </ng-template>

      <div *ngSwitchCase="'failed'"
           class="g-image-error-message">
        <div *ngIf="errorTemplate; else defaultError"
             [innerHTML]="errorTemplate"></div>
        <ng-template #defaultError>
          <ng-container *ngIf="isThumbnail; else isLarge">
            <h4>
              <div class="gallery-thumb-error" [innerHTML]="errorSvg"></div>
            </h4>
          </ng-container>
          <ng-template #isLarge>
            <h2>
              <div class="gallery-image-error" [innerHTML]="errorSvg"></div>
            </h2>
            <p>Unable to load the image!</p>
          </ng-template>
        </ng-template>
      </div>

      <ng-container *ngSwitchCase="'loading'">
        <div *ngIf="loaderTemplate; else defaultLoader"
             class="g-loading"
             [innerHTML]="loaderTemplate">
        </div>
        <ng-template #defaultLoader>
          <div *ngIf="isThumbnail" class="g-thumb-loading"></div>
        </ng-template>
      </ng-container>
    </ng-container>
  `, isInline: true, styles: [":host{display:flex;width:100%;height:100%;max-height:100%;max-width:100%;transition:opacity .3s cubic-bezier(.5,0,.5,1);opacity:var(--g-thumb-opacity)}:host[imageState=success]{align-self:center}:host ::ng-deep svg{width:100%;height:100%}.gallery-image-error{width:100px;height:100px}.gallery-thumb-error{width:40px;height:40px}img.g-image-item{object-fit:var(--image-object-fit);width:100%;height:100%;pointer-events:none;max-height:100%;max-width:100%}.g-image-error-message{position:absolute;z-index:10;inset:0;color:#fff;display:flex;align-items:center;justify-content:center;flex-direction:column}h2,h4{color:coral;margin:0}h2{font-size:3.5em;margin-bottom:.3em}h4{font-size:1.6em}.g-loading{position:absolute;transform:translate3d(-50%,-50%,0);left:50%;top:50%;width:80px;height:80px}.g-active-thumb .g-thumb-loading{background-color:#464646}.g-thumb-loading{position:relative;overflow:hidden;width:100%;height:100%;background-color:#262626}.g-thumb-loading:before{content:\"\";position:absolute;inset:0 0 0 50%;z-index:1;width:500%;margin-left:-250%;animation:phAnimation .8s linear infinite;background:linear-gradient(to right,#fff0 46%,#ffffff59,#fff0 54%) 50% 50%}@keyframes phAnimation{0%{transform:translate3d(-30%,0,0)}to{transform:translate3d(30%,0,0)}}\n"], dependencies: [{ kind: "directive", type: NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: ImgRecognizer, selector: "img[galleryImage]", inputs: ["galleryImage"] }], animations: [
            trigger('fadeIn', [
                transition('* => success', [
                    style({ opacity: 0 }),
                    animate('300ms ease-in', style({ opacity: 1 }))
                ])
            ])
        ], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryImageComponent, decorators: [{
            type: Component,
            args: [{ selector: 'gallery-image', changeDetection: ChangeDetectionStrategy.OnPush, animations: [
                        trigger('fadeIn', [
                            transition('* => success', [
                                style({ opacity: 0 }),
                                animate('300ms ease-in', style({ opacity: 1 }))
                            ])
                        ])
                    ], template: `
    <ng-container [ngSwitch]="state">

      <ng-container *ngIf="isThumbnail; else main">
        <img [@fadeIn]="state"
             [src]="src"
             [attr.alt]="alt"
             [attr.loading]="loadingAttr"
             [style.visibility]="state === 'success' ? 'visible' : 'hidden'"
             class="g-image-item"
             (load)="state = 'success'"
             (error)="state = 'failed'; error.emit($event)"/>
      </ng-container>
      <ng-template #main>
        <img [galleryImage]="index"
             [@fadeIn]="state"
             [src]="src"
             [attr.alt]="alt"
             [attr.loading]="loadingAttr"
             [style.visibility]="state === 'success' ? 'visible' : 'hidden'"
             class="g-image-item"
             (load)="state = 'success'"
             (error)="state = 'failed'; error.emit($event)"/>
      </ng-template>

      <div *ngSwitchCase="'failed'"
           class="g-image-error-message">
        <div *ngIf="errorTemplate; else defaultError"
             [innerHTML]="errorTemplate"></div>
        <ng-template #defaultError>
          <ng-container *ngIf="isThumbnail; else isLarge">
            <h4>
              <div class="gallery-thumb-error" [innerHTML]="errorSvg"></div>
            </h4>
          </ng-container>
          <ng-template #isLarge>
            <h2>
              <div class="gallery-image-error" [innerHTML]="errorSvg"></div>
            </h2>
            <p>Unable to load the image!</p>
          </ng-template>
        </ng-template>
      </div>

      <ng-container *ngSwitchCase="'loading'">
        <div *ngIf="loaderTemplate; else defaultLoader"
             class="g-loading"
             [innerHTML]="loaderTemplate">
        </div>
        <ng-template #defaultLoader>
          <div *ngIf="isThumbnail" class="g-thumb-loading"></div>
        </ng-template>
      </ng-container>
    </ng-container>
  `, standalone: true, imports: [NgSwitch, NgSwitchCase, NgIf, ImgRecognizer], styles: [":host{display:flex;width:100%;height:100%;max-height:100%;max-width:100%;transition:opacity .3s cubic-bezier(.5,0,.5,1);opacity:var(--g-thumb-opacity)}:host[imageState=success]{align-self:center}:host ::ng-deep svg{width:100%;height:100%}.gallery-image-error{width:100px;height:100px}.gallery-thumb-error{width:40px;height:40px}img.g-image-item{object-fit:var(--image-object-fit);width:100%;height:100%;pointer-events:none;max-height:100%;max-width:100%}.g-image-error-message{position:absolute;z-index:10;inset:0;color:#fff;display:flex;align-items:center;justify-content:center;flex-direction:column}h2,h4{color:coral;margin:0}h2{font-size:3.5em;margin-bottom:.3em}h4{font-size:1.6em}.g-loading{position:absolute;transform:translate3d(-50%,-50%,0);left:50%;top:50%;width:80px;height:80px}.g-active-thumb .g-thumb-loading{background-color:#464646}.g-thumb-loading{position:relative;overflow:hidden;width:100%;height:100%;background-color:#262626}.g-thumb-loading:before{content:\"\";position:absolute;inset:0 0 0 50%;z-index:1;width:500%;margin-left:-250%;animation:phAnimation .8s linear infinite;background:linear-gradient(to right,#fff0 46%,#ffffff59,#fff0 54%) 50% 50%}@keyframes phAnimation{0%{transform:translate3d(-30%,0,0)}to{transform:translate3d(30%,0,0)}}\n"] }]
        }], ctorParameters: () => [{ type: i1$1.DomSanitizer }], propDecorators: { isThumbnail: [{
                type: Input
            }], index: [{
                type: Input
            }], loadingAttr: [{
                type: Input
            }], alt: [{
                type: Input
            }], src: [{
                type: Input
            }], loadingIcon: [{
                type: Input
            }], loadingError: [{
                type: Input
            }], errorIcon: [{
                type: Input
            }], error: [{
                type: Output
            }], imageState: [{
                type: HostBinding,
                args: ['attr.imageState']
            }] } });

class GalleryItemComponent {
    get isActive() {
        return this.index === this.currIndex;
    }
    get isIndexAttr() {
        return this.index;
    }
    get itemState() {
        return this.state$.value;
    }
    get imageContext() {
        return {
            $implicit: this.imageData,
            index: this.index,
            type: this.type,
            active: this.isActive,
            count: this.count,
            first: this.index === 0,
            last: this.index === this.count - 1
        };
    }
    get itemContext() {
        return {
            $implicit: this.data,
            index: this.index,
            type: this.type,
            active: this.isActive,
            count: this.count,
            first: this.index === 0,
            last: this.index === this.count - 1
        };
    }
    get nativeElement() {
        return this.el.nativeElement;
    }
    get isAutoPlay() {
        if (this.isActive) {
            if (this.type === GalleryItemTypes.Video || this.type === GalleryItemTypes.Youtube || this.type === GalleryItemTypes.Vimeo) {
                return this.videoData.autoplay;
            }
        }
    }
    get youtubeSrc() {
        let autoplay = 0;
        if (this.isActive && this.type === GalleryItemTypes.Youtube && this.data.autoplay) {
            autoplay = 1;
        }
        const url = new URL(this.data.src);
        url.search = new URLSearchParams({
            wmode: 'transparent',
            ...this.data.params,
            autoplay
        }).toString();
        return url.href;
    }
    get vimeoSrc() {
        let autoplay = 0;
        if (this.isActive && this.type === GalleryItemTypes.Vimeo) {
            if (this.data.autoplay) {
                autoplay = 1;
            }
        }
        const url = new URL(this.data.src);
        url.search = new URLSearchParams({
            ...this.data.params,
            autoplay,
        }).toString();
        return url.href;
    }
    get load() {
        switch (this.config.loadingStrategy) {
            case LoadingStrategy.Preload:
                return true;
            case LoadingStrategy.Lazy:
                return this.currIndex === this.index;
            default:
                return this.currIndex === this.index || this.currIndex === this.index - 1 || this.currIndex === this.index + 1;
        }
    }
    get imageData() {
        return this.data;
    }
    get videoData() {
        return this.data;
    }
    constructor(el) {
        this.el = el;
        this.Types = GalleryItemTypes;
        /** A stream that indicates that the height was emitted after the image is loaded, used only for gallery image types */
        this.state$ = new BehaviorSubject('loading');
        /** Stream that emits when an error occurs */
        this.error = new EventEmitter();
    }
    ngAfterViewInit() {
        // If item does not contain an image, then set the state to DONE
        if (!this.isItemContainImage) {
            this.state$.next('success');
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryItemComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.1", type: GalleryItemComponent, isStandalone: true, selector: "gallery-item", inputs: { config: "config", index: "index", count: "count", currIndex: "currIndex", type: "type", data: "data" }, outputs: { error: "error" }, host: { properties: { "class.g-active-item": "this.isActive", "attr.galleryIndex": "this.isIndexAttr", "attr.itemState": "this.itemState" } }, ngImport: i0, template: `
    <ng-container *ngIf="load" [ngSwitch]="type">
      <ng-container *ngSwitchCase="Types.Image">
        <gallery-image [src]="imageData.src"
                       [alt]="imageData.alt"
                       [index]="index"
                       [loadingAttr]="config.loadingAttr"
                       [loadingIcon]="config.loadingIcon"
                       [loadingError]="config.loadingError"
                       (error)="error.emit($event)"></gallery-image>

        <div *ngIf="config.imageTemplate" class="g-template g-item-template">
          <ng-container *ngTemplateOutlet="config.imageTemplate; context: imageContext"></ng-container>
        </div>
      </ng-container>

      <gallery-video *ngSwitchCase="Types.Video"
                     [src]="videoData.src"
                     [mute]="videoData.mute"
                     [poster]="videoData.poster"
                     [controls]="videoData.controls"
                     [controlsList]="videoData.controlsList"
                     [disablePictureInPicture]="videoData.disablePictureInPicture"
                     [play]="isAutoPlay"
                     [pause]="currIndex !== index"
                     (error)="error.emit($event)"></gallery-video>

      <gallery-iframe *ngSwitchCase="Types.Youtube"
                      [src]="youtubeSrc"
                      [autoplay]="isAutoPlay"
                      [loadingAttr]="config.loadingAttr"
                      [pause]="currIndex !== index"></gallery-iframe>

      <gallery-iframe *ngSwitchCase="Types.Vimeo"
                      [src]="vimeoSrc"
                      [autoplay]="isAutoPlay"
                      [loadingAttr]="config.loadingAttr"
                      [pause]="currIndex !== index"></gallery-iframe>

      <gallery-iframe *ngSwitchCase="Types.Iframe"
                      [src]="data.src"
                      [loadingAttr]="config.loadingAttr"></gallery-iframe>

      <ng-container *ngSwitchDefault>
        <div *ngIf="config.itemTemplate" class="g-template g-item-template">
          <ng-container *ngTemplateOutlet="config.itemTemplate; context: itemContext"></ng-container>
        </div>
      </ng-container>
    </ng-container>
  `, isInline: true, styles: [":host{cursor:var(--g-item-cursor);height:var(--g-item-height);width:var(--g-item-width);max-height:var(--g-item-max-height);max-width:var(--slider-width);z-index:10;position:relative;overflow:hidden;display:flex;flex-direction:column;flex:0 0 auto;scroll-snap-align:center;-webkit-user-select:none;user-select:none;-webkit-user-drag:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}:host[itemState=loading]{width:var(--slider-width);height:var(--slider-height)}:host>*{height:100%}:host ::ng-deep video,:host ::ng-deep iframe{width:100%;height:100%}gallery-image{width:var(--g-item-width);height:var(--g-item-height)}.g-template{position:absolute;z-index:10;inset:0;color:#fff;display:flex;align-items:center;justify-content:center;flex-direction:column}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i1.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i1.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: i1.NgSwitchDefault, selector: "[ngSwitchDefault]" }, { kind: "component", type: GalleryImageComponent, selector: "gallery-image", inputs: ["isThumbnail", "index", "loadingAttr", "alt", "src", "loadingIcon", "loadingError", "errorIcon"], outputs: ["error"] }, { kind: "component", type: GalleryVideoComponent, selector: "gallery-video", inputs: ["src", "poster", "mute", "loop", "controls", "controlsList", "disableRemotePlayback", "disablePictureInPicture", "pause", "play"], outputs: ["error"] }, { kind: "component", type: GalleryIframeComponent, selector: "gallery-iframe", inputs: ["src", "pause", "autoplay", "loadingAttr"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'gallery-item', changeDetection: ChangeDetectionStrategy.OnPush, template: `
    <ng-container *ngIf="load" [ngSwitch]="type">
      <ng-container *ngSwitchCase="Types.Image">
        <gallery-image [src]="imageData.src"
                       [alt]="imageData.alt"
                       [index]="index"
                       [loadingAttr]="config.loadingAttr"
                       [loadingIcon]="config.loadingIcon"
                       [loadingError]="config.loadingError"
                       (error)="error.emit($event)"></gallery-image>

        <div *ngIf="config.imageTemplate" class="g-template g-item-template">
          <ng-container *ngTemplateOutlet="config.imageTemplate; context: imageContext"></ng-container>
        </div>
      </ng-container>

      <gallery-video *ngSwitchCase="Types.Video"
                     [src]="videoData.src"
                     [mute]="videoData.mute"
                     [poster]="videoData.poster"
                     [controls]="videoData.controls"
                     [controlsList]="videoData.controlsList"
                     [disablePictureInPicture]="videoData.disablePictureInPicture"
                     [play]="isAutoPlay"
                     [pause]="currIndex !== index"
                     (error)="error.emit($event)"></gallery-video>

      <gallery-iframe *ngSwitchCase="Types.Youtube"
                      [src]="youtubeSrc"
                      [autoplay]="isAutoPlay"
                      [loadingAttr]="config.loadingAttr"
                      [pause]="currIndex !== index"></gallery-iframe>

      <gallery-iframe *ngSwitchCase="Types.Vimeo"
                      [src]="vimeoSrc"
                      [autoplay]="isAutoPlay"
                      [loadingAttr]="config.loadingAttr"
                      [pause]="currIndex !== index"></gallery-iframe>

      <gallery-iframe *ngSwitchCase="Types.Iframe"
                      [src]="data.src"
                      [loadingAttr]="config.loadingAttr"></gallery-iframe>

      <ng-container *ngSwitchDefault>
        <div *ngIf="config.itemTemplate" class="g-template g-item-template">
          <ng-container *ngTemplateOutlet="config.itemTemplate; context: itemContext"></ng-container>
        </div>
      </ng-container>
    </ng-container>
  `, standalone: true, imports: [CommonModule, GalleryImageComponent, GalleryVideoComponent, GalleryIframeComponent], styles: [":host{cursor:var(--g-item-cursor);height:var(--g-item-height);width:var(--g-item-width);max-height:var(--g-item-max-height);max-width:var(--slider-width);z-index:10;position:relative;overflow:hidden;display:flex;flex-direction:column;flex:0 0 auto;scroll-snap-align:center;-webkit-user-select:none;user-select:none;-webkit-user-drag:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}:host[itemState=loading]{width:var(--slider-width);height:var(--slider-height)}:host>*{height:100%}:host ::ng-deep video,:host ::ng-deep iframe{width:100%;height:100%}gallery-image{width:var(--g-item-width);height:var(--g-item-height)}.g-template{position:absolute;z-index:10;inset:0;color:#fff;display:flex;align-items:center;justify-content:center;flex-direction:column}\n"] }]
        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { config: [{
                type: Input
            }], index: [{
                type: Input
            }], count: [{
                type: Input
            }], currIndex: [{
                type: Input
            }], type: [{
                type: Input
            }], data: [{
                type: Input
            }], error: [{
                type: Output
            }], isActive: [{
                type: HostBinding,
                args: ['class.g-active-item']
            }], isIndexAttr: [{
                type: HostBinding,
                args: ['attr.galleryIndex']
            }], itemState: [{
                type: HostBinding,
                args: ['attr.itemState']
            }] } });

class ItemIntersectionObserver {
    get _viewport() {
        return this._item.nativeElement.parentElement.parentElement;
    }
    constructor(_zone, _item) {
        this._zone = _zone;
        this._item = _item;
        this._sensor = new ActiveItemObserver();
        this.activeIndexChange = new EventEmitter();
    }
    ngOnChanges() {
        (this.config.itemAutosize && !this.disabled) ? this._subscribe() : this._unsubscribe();
    }
    ngOnDestroy() {
        this._unsubscribe();
    }
    _subscribe() {
        this._unsubscribe();
        if (!!this.adapter) {
            this._zone.runOutsideAngular(() => {
                this._currentSubscription = combineLatest([
                    resizeObservable(this._viewport),
                    resizeObservable(this._item.nativeElement)
                ]).pipe(switchMap(() => this._item.state$), filter((state) => state !== 'loading'), switchMap(() => {
                    const rootMargin = this.adapter.getElementRootMargin(this._viewport, this._item.nativeElement);
                    if (this.config.debug) {
                        this._item.nativeElement.style.setProperty('--item-intersection-margin', `"VIEWPORT(${this._viewport.clientWidth}x${this._viewport.clientHeight}) ITEM(${this._item.nativeElement.clientWidth}x${this._item.nativeElement.clientHeight}) INTERSECTION(${rootMargin})"`);
                    }
                    return this._sensor.observe(this._viewport, [this._item.nativeElement], rootMargin);
                })).subscribe((index) => {
                    this._zone.run(() => this.activeIndexChange.emit(index));
                });
            });
        }
    }
    _unsubscribe() {
        this._currentSubscription?.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: ItemIntersectionObserver, deps: [{ token: i0.NgZone }, { token: GalleryItemComponent }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.1", type: ItemIntersectionObserver, isStandalone: true, selector: "[itemIntersectionObserver]", inputs: { adapter: "adapter", config: "config", disabled: ["itemIntersectionObserverDisabled", "disabled"] }, outputs: { activeIndexChange: "activeIndexChange" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: ItemIntersectionObserver, decorators: [{
            type: Directive,
            args: [{
                    selector: '[itemIntersectionObserver]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: GalleryItemComponent }], propDecorators: { adapter: [{
                type: Input
            }], config: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: ['itemIntersectionObserverDisabled']
            }], activeIndexChange: [{
                type: Output
            }] } });

class SliderResizeObserver {
    get _viewport() {
        return this._el.nativeElement;
    }
    get _galleryCore() {
        return this._el.nativeElement.parentElement.parentElement.parentElement;
    }
    get _isAutoHeight() {
        return this.config.autoHeight &&
            !this.config.itemAutosize &&
            this.config.orientation === 'horizontal' &&
            (this.config.thumbPosition === 'top' || this.config.thumbPosition === 'bottom');
    }
    constructor(_el, _zone, _gallery, _imgManager) {
        this._el = _el;
        this._zone = _zone;
        this._gallery = _gallery;
        this._imgManager = _imgManager;
        this.isResizingChange = new EventEmitter();
    }
    ngOnInit() {
        const galleryRef = this._gallery.ref(this.galleryId);
        // Check if height has transition for the auto-height feature
        const transitionDuration = getComputedStyle(this._viewport).getPropertyValue('transition-duration');
        if (parseFloat(transitionDuration) === 0) {
            this._afterHeightChanged$ = of(null);
        }
        else {
            this._afterHeightChanged$ = fromEvent(this._viewport, 'transitionend');
        }
        this._zone.runOutsideAngular(() => {
            // Detect if the size of the slider has changed detecting current index on scroll
            this._resizeSubscription = resizeObservable(this._viewport, (observer) => this._resizeObserver = observer).pipe(
            // Check if resize should skip due to re-observing the slider
            filter(() => !this._shouldSkip || !(this._shouldSkip = false)), 
            // Immediately set visibility to hidden to avoid changing the active item caused by appearance of other items when size is expanded
            tap(() => this.setResizingState()), debounceTime(this.config.resizeDebounceTime, animationFrameScheduler), tap(async (entry) => {
                // Update CSS variables with the proper values
                this.updateSliderSize();
                if (this._isAutoHeight) {
                    const img = await firstValueFrom(this._imgManager.getActiveItem(galleryRef.state));
                    // If img height is identical to the viewport height then skip
                    if (img.height === this._viewport.clientHeight) {
                        this.resetResizingState();
                    }
                    else {
                        // Unobserve the slider while the height is being changed
                        this.setResizingState({ unobserve: true });
                        // Change the height
                        this._galleryCore.style.setProperty('--slider-height', `${img.height}px`);
                        // Wait until height transition ends
                        await firstValueFrom(this._afterHeightChanged$);
                        this.resetResizingState({
                            // Mark to skip first emit after re-observing the slider if height content rect height and client height are identical
                            shouldSkip: entry.contentRect.height === this._viewport.clientHeight,
                            observe: true
                        });
                    }
                }
                else {
                    requestAnimationFrame(() => this.resetResizingState({ shouldSkip: true }));
                }
            })).subscribe();
        });
    }
    ngOnChanges() {
        this._isAutoHeight ? this._subscribeAutoHeight() : this._unsubscribeAutoHeight();
    }
    ngOnDestroy() {
        this._resizeSubscription?.unsubscribe();
        this._unsubscribeAutoHeight();
    }
    ngAfterViewChecked() {
        this.updateSliderSize();
    }
    updateSliderSize() {
        // Update slider width and height CSS variables
        this._galleryCore.style.setProperty('--slider-width', `${this._viewport.clientWidth}px`);
        // Only update height if auto-height is false, because when it's true, another function will take care of it
        if (!this.config.autoHeight) {
            this._galleryCore.style.setProperty('--slider-height', `${this._viewport.clientHeight}px`);
        }
        this.updateCentralizeCSSVariables();
    }
    updateCentralizeCSSVariables() {
        if (this.config.itemAutosize) {
            this._galleryCore.style.setProperty('--slider-centralize-start-size', `${this.adapter.getCentralizerStartSize()}px`);
            this._galleryCore.style.setProperty('--slider-centralize-end-size', `${this.adapter.getCentralizerEndSize()}px`);
        }
    }
    _subscribeAutoHeight() {
        this._unsubscribeAutoHeight();
        this._shouldSkip = false;
        this._zone.runOutsideAngular(() => {
            const galleryRef = this._gallery.ref(this.galleryId);
            // TODO: Why is galleryRef.state emits when screen size changes?
            const state = galleryRef.state.pipe(distinctUntilChanged((a, b) => a.currIndex === b.currIndex));
            this._autoHeightSubscription = this._imgManager.getActiveItem(state).pipe(switchMap((img) => {
                this.setResizingState({ unobserve: true });
                this._galleryCore.style.setProperty('--slider-height', `${img.clientHeight}px`);
                // Check if the new item height is equal to the current height, there will be no transition,
                // So reset resizing state
                if (img.height === this._viewport.clientHeight) {
                    this.resetResizingState({ shouldSkip: true, observe: true });
                    return EMPTY;
                }
                return this._afterHeightChanged$.pipe(tap(() => this.resetResizingState({ shouldSkip: true, observe: true })), take(1));
            })).subscribe();
        });
    }
    _unsubscribeAutoHeight() {
        this._autoHeightSubscription?.unsubscribe();
    }
    setResizingState({ unobserve } = {}) {
        this._zone.run(() => {
            this.isResizingChange.emit(true);
        });
        this._viewport.classList.add('g-resizing');
        if (unobserve) {
            // Unobserve the slider while the height is being changed
            this._resizeObserver.unobserve(this._viewport);
        }
    }
    resetResizingState({ shouldSkip, observe } = {}) {
        this._zone.run(() => {
            this.isResizingChange.emit(false);
        });
        this._viewport.classList.remove('g-resizing');
        this._shouldSkip = shouldSkip;
        if (observe) {
            this._resizeObserver.observe(this._viewport);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: SliderResizeObserver, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: Gallery }, { token: ImgManager }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.1", type: SliderResizeObserver, isStandalone: true, selector: "[sliderResizeObserver]", inputs: { galleryId: "galleryId", adapter: "adapter", config: "config" }, outputs: { isResizingChange: "isResizingChange" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: SliderResizeObserver, decorators: [{
            type: Directive,
            args: [{
                    selector: '[sliderResizeObserver]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: Gallery }, { type: ImgManager }], propDecorators: { galleryId: [{
                type: Input
            }], adapter: [{
                type: Input
            }], config: [{
                type: Input
            }], isResizingChange: [{
                type: Output
            }] } });

class GallerySliderComponent {
    get slider() {
        return this.sliderEl.nativeElement;
    }
    constructor(_gallery) {
        this._gallery = _gallery;
        /** Stream that emits the slider position */
        this.position$ = new Subject();
        /** Stream that emits when item is clicked */
        this.itemClick = new EventEmitter();
        /** Stream that emits when an error occurs */
        this.error = new EventEmitter();
        this.items = new QueryList();
    }
    ngOnChanges(changes) {
        if (changes.config) {
            if (changes.config.currentValue?.orientation !== changes.config.previousValue?.orientation) {
                switch (this.config.orientation) {
                    case Orientation.Horizontal:
                        this.adapter = new HorizontalAdapter(this.slider, this.config);
                        break;
                    case Orientation.Vertical:
                        this.adapter = new VerticalAdapter(this.slider, this.config);
                        break;
                }
            }
            if (!changes.config.firstChange) {
                // Keep the correct sliding position when direction changes
                requestAnimationFrame(() => {
                    this.scrollToIndex(this.state.currIndex, 'auto');
                });
            }
        }
        // Scroll to current index
        if (changes.state) {
            if (changes.state.currentValue?.currIndex !== changes.state.previousValue?.currIndex) {
                requestAnimationFrame(() => {
                    this.scrollToIndex(this.state.currIndex, changes.state.firstChange ? 'auto' : this.state.behavior);
                });
            }
        }
    }
    ngAfterViewInit() {
        this.items.notifyOnChanges();
        this.items$ = this.items.changes.pipe(
        // In some cases, items is not notified at first, need to force start the stream
        startWith(null), map(() => this.items.toArray()));
    }
    trackByFn(index, item) {
        return item.type;
    }
    onActiveIndexChange(index) {
        if (index === -1) {
            // Reset active index position
            this.scrollToIndex(this.state.currIndex, 'smooth');
        }
        else {
            this._gallery.ref(this.galleryId).set(index, 'smooth');
        }
    }
    scrollToIndex(index, behavior) {
        const el = this.items.get(index)?.nativeElement;
        if (el) {
            const pos = this.adapter.getScrollToValue(el, behavior || this.config.scrollBehavior);
            this.position$.next(pos);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GallerySliderComponent, deps: [{ token: Gallery }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.1", type: GallerySliderComponent, isStandalone: true, selector: "gallery-slider", inputs: { galleryId: "galleryId", state: "state", config: "config" }, outputs: { itemClick: "itemClick", error: "error" }, viewQueries: [{ propertyName: "sliderEl", first: true, predicate: ["slider"], descendants: true, static: true }, { propertyName: "items", predicate: GalleryItemComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div #slider
         class="g-slider"
         [attr.centralised]="config.itemAutosize"
         [smoothScroll]="position$ | async"
         [smoothScrollInterruptOnMousemove]="!config.disableMouseScroll"
         sliderIntersectionObserver
         [sliderIntersectionObserverDisabled]="isScrolling || isSliding || isResizing"
         [hammerSliding]="!config.disableMouseScroll"
         [adapter]="adapter"
         [items]="items$ | async"
         [config]="config"
         [state]="state"
         [galleryId]="galleryId"
         (isScrollingChange)="isScrolling = $event"
         (isSlidingChange)="isSliding = $event"
         (activeIndexChange)="onActiveIndexChange($event)"
         (isResizingChange)="isResizing = $event"
         sliderResizeObserver>
      <div class="g-slider-content">
        <gallery-item *ngFor="let item of state.items; trackBy: trackByFn index as i"
                      [attr.galleryId]="galleryId"
                      [type]="item.type"
                      [config]="config"
                      [data]="item.data"
                      [currIndex]="state.currIndex"
                      [index]="i"
                      [count]="state.items.length"
                      itemIntersectionObserver
                      [itemIntersectionObserverDisabled]="isScrolling || isSliding || isResizing"
                      [adapter]="adapter"
                      (activeIndexChange)="onActiveIndexChange($event)"
                      (click)="itemClick.emit(i)"
                      (error)="error.emit({ itemIndex: i, error: $event })"/>
      </div>

      <div *ngIf="config.debug" class="g-slider-debug">
        <div class="g-slider-resizing">RESIZING</div>
        <div class="g-slider-scrolling">SCROLLING</div>
        <div class="g-slider-sliding">SLIDING</div>
      </div>
    </div>
    <ng-content></ng-content>
  `, isInline: true, styles: [":host{position:relative;display:flex;align-items:center;justify-content:center;overflow:hidden;order:1;flex:1}.g-slider{display:flex;align-items:center;transition:var(--g-height-transition);min-height:100%;min-width:100%;max-height:100%;max-width:100%;height:var(--slider-height, 100%);width:var(--slider-width, 100%);overflow:var(--slider-overflow);scroll-snap-type:var(--slider-scroll-snap-type);flex-direction:var(--slider-flex-direction);scrollbar-width:none}.g-slider::-webkit-scrollbar{display:none}.g-slider.g-sliding .g-slider-content,.g-slider.g-scrolling .g-slider-content{pointer-events:none}.g-slider[centralised=true]:before,.g-slider[centralised=true]:after{content:\"\"}.g-slider[centralised=true]:before{flex:0 0 var(--slider-centralize-start-size)}.g-slider[centralised=true]:after{flex:0 0 var(--slider-centralize-end-size)}.g-slider-content{flex:0 0 auto;display:flex;align-items:center;gap:1px;width:var(--slider-content-width, unset);height:var(--slider-content-height, unset);flex-direction:var(--slider-flex-direction)}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i1.AsyncPipe, name: "async" }, { kind: "component", type: GalleryItemComponent, selector: "gallery-item", inputs: ["config", "index", "count", "currIndex", "type", "data"], outputs: ["error"] }, { kind: "directive", type: SmoothScroll, selector: "[smoothScroll]", inputs: ["smoothScroll", "adapter", "config", "smoothScrollInterruptOnMousemove"], outputs: ["isScrollingChange"] }, { kind: "directive", type: HammerSliding, selector: "[hammerSliding]", inputs: ["hammerSliding", "galleryId", "items", "adapter", "state", "config"], outputs: ["activeIndexChange", "isSlidingChange"] }, { kind: "directive", type: SliderIntersectionObserver, selector: "[sliderIntersectionObserver]", inputs: ["adapter", "items", "config", "sliderIntersectionObserverDisabled"], outputs: ["activeIndexChange"] }, { kind: "directive", type: ItemIntersectionObserver, selector: "[itemIntersectionObserver]", inputs: ["adapter", "config", "itemIntersectionObserverDisabled"], outputs: ["activeIndexChange"] }, { kind: "directive", type: SliderResizeObserver, selector: "[sliderResizeObserver]", inputs: ["galleryId", "adapter", "config"], outputs: ["isResizingChange"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GallerySliderComponent, decorators: [{
            type: Component,
            args: [{ selector: 'gallery-slider', changeDetection: ChangeDetectionStrategy.OnPush, template: `
    <div #slider
         class="g-slider"
         [attr.centralised]="config.itemAutosize"
         [smoothScroll]="position$ | async"
         [smoothScrollInterruptOnMousemove]="!config.disableMouseScroll"
         sliderIntersectionObserver
         [sliderIntersectionObserverDisabled]="isScrolling || isSliding || isResizing"
         [hammerSliding]="!config.disableMouseScroll"
         [adapter]="adapter"
         [items]="items$ | async"
         [config]="config"
         [state]="state"
         [galleryId]="galleryId"
         (isScrollingChange)="isScrolling = $event"
         (isSlidingChange)="isSliding = $event"
         (activeIndexChange)="onActiveIndexChange($event)"
         (isResizingChange)="isResizing = $event"
         sliderResizeObserver>
      <div class="g-slider-content">
        <gallery-item *ngFor="let item of state.items; trackBy: trackByFn index as i"
                      [attr.galleryId]="galleryId"
                      [type]="item.type"
                      [config]="config"
                      [data]="item.data"
                      [currIndex]="state.currIndex"
                      [index]="i"
                      [count]="state.items.length"
                      itemIntersectionObserver
                      [itemIntersectionObserverDisabled]="isScrolling || isSliding || isResizing"
                      [adapter]="adapter"
                      (activeIndexChange)="onActiveIndexChange($event)"
                      (click)="itemClick.emit(i)"
                      (error)="error.emit({ itemIndex: i, error: $event })"/>
      </div>

      <div *ngIf="config.debug" class="g-slider-debug">
        <div class="g-slider-resizing">RESIZING</div>
        <div class="g-slider-scrolling">SCROLLING</div>
        <div class="g-slider-sliding">SLIDING</div>
      </div>
    </div>
    <ng-content></ng-content>
  `, standalone: true, imports: [CommonModule, GalleryItemComponent, SmoothScroll, HammerSliding, SliderIntersectionObserver, ItemIntersectionObserver, SliderResizeObserver], styles: [":host{position:relative;display:flex;align-items:center;justify-content:center;overflow:hidden;order:1;flex:1}.g-slider{display:flex;align-items:center;transition:var(--g-height-transition);min-height:100%;min-width:100%;max-height:100%;max-width:100%;height:var(--slider-height, 100%);width:var(--slider-width, 100%);overflow:var(--slider-overflow);scroll-snap-type:var(--slider-scroll-snap-type);flex-direction:var(--slider-flex-direction);scrollbar-width:none}.g-slider::-webkit-scrollbar{display:none}.g-slider.g-sliding .g-slider-content,.g-slider.g-scrolling .g-slider-content{pointer-events:none}.g-slider[centralised=true]:before,.g-slider[centralised=true]:after{content:\"\"}.g-slider[centralised=true]:before{flex:0 0 var(--slider-centralize-start-size)}.g-slider[centralised=true]:after{flex:0 0 var(--slider-centralize-end-size)}.g-slider-content{flex:0 0 auto;display:flex;align-items:center;gap:1px;width:var(--slider-content-width, unset);height:var(--slider-content-height, unset);flex-direction:var(--slider-flex-direction)}\n"] }]
        }], ctorParameters: () => [{ type: Gallery }], propDecorators: { galleryId: [{
                type: Input
            }], state: [{
                type: Input
            }], config: [{
                type: Input
            }], itemClick: [{
                type: Output
            }], error: [{
                type: Output
            }], sliderEl: [{
                type: ViewChild,
                args: ['slider', { static: true }]
            }], items: [{
                type: ViewChildren,
                args: [GalleryItemComponent]
            }] } });

class GalleryThumbComponent {
    get isActive() {
        return this.index === this.currIndex;
    }
    get isIndexAttr() {
        return this.index;
    }
    get imageContext() {
        return {
            $implicit: this.data,
            index: this.index,
            type: this.type,
            active: this.isActive,
            count: this.count,
            first: this.index === 0,
            last: this.index === this.count - 1
        };
    }
    get nativeElement() {
        return this.el.nativeElement;
    }
    constructor(el) {
        this.el = el;
        this.error = new EventEmitter();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryThumbComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.1", type: GalleryThumbComponent, isStandalone: true, selector: "gallery-thumb", inputs: { config: "config", index: "index", count: "count", currIndex: "currIndex", type: "type", data: "data" }, outputs: { error: "error" }, host: { properties: { "class.g-active-thumb": "this.isActive", "attr.galleryIndex": "this.isIndexAttr" } }, ngImport: i0, template: `
    <gallery-image [src]="data.thumb"
                   [alt]="data.alt + '-thumbnail'"
                   [isThumbnail]="true"
                   [loadingIcon]="config.thumbLoadingIcon"
                   [loadingError]="config.thumbLoadingError"
                   (error)="error.emit($event)"></gallery-image>

    <div *ngIf="config.thumbTemplate" class="g-template g-thumb-template">
      <ng-container *ngTemplateOutlet="config.thumbTemplate; context: imageContext"></ng-container>
    </div>
  `, isInline: true, styles: [":host{cursor:var(--g-thumb-cursor);height:var(--g-thumb-height);width:var(--g-thumb-width);max-height:var(--g-thumb-height);max-width:var(--g-thumb-width);align-self:center;background:#000;position:relative;display:flex;overflow:hidden;flex-direction:column;flex:0 0 auto;scroll-snap-align:center;-webkit-user-select:none;user-select:none;-webkit-user-drag:none;-webkit-tap-highlight-color:rgba(0,0,0,0);--g-thumb-opacity: .5}:host.g-active-thumb{--g-thumb-opacity: 1}.g-template{position:absolute;z-index:10;inset:0;color:#fff;display:flex;align-items:center;justify-content:center;flex-direction:column}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: GalleryImageComponent, selector: "gallery-image", inputs: ["isThumbnail", "index", "loadingAttr", "alt", "src", "loadingIcon", "loadingError", "errorIcon"], outputs: ["error"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryThumbComponent, decorators: [{
            type: Component,
            args: [{ selector: 'gallery-thumb', changeDetection: ChangeDetectionStrategy.OnPush, template: `
    <gallery-image [src]="data.thumb"
                   [alt]="data.alt + '-thumbnail'"
                   [isThumbnail]="true"
                   [loadingIcon]="config.thumbLoadingIcon"
                   [loadingError]="config.thumbLoadingError"
                   (error)="error.emit($event)"></gallery-image>

    <div *ngIf="config.thumbTemplate" class="g-template g-thumb-template">
      <ng-container *ngTemplateOutlet="config.thumbTemplate; context: imageContext"></ng-container>
    </div>
  `, standalone: true, imports: [CommonModule, GalleryImageComponent], styles: [":host{cursor:var(--g-thumb-cursor);height:var(--g-thumb-height);width:var(--g-thumb-width);max-height:var(--g-thumb-height);max-width:var(--g-thumb-width);align-self:center;background:#000;position:relative;display:flex;overflow:hidden;flex-direction:column;flex:0 0 auto;scroll-snap-align:center;-webkit-user-select:none;user-select:none;-webkit-user-drag:none;-webkit-tap-highlight-color:rgba(0,0,0,0);--g-thumb-opacity: .5}:host.g-active-thumb{--g-thumb-opacity: 1}.g-template{position:absolute;z-index:10;inset:0;color:#fff;display:flex;align-items:center;justify-content:center;flex-direction:column}\n"] }]
        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { config: [{
                type: Input
            }], index: [{
                type: Input
            }], count: [{
                type: Input
            }], currIndex: [{
                type: Input
            }], type: [{
                type: Input
            }], data: [{
                type: Input
            }], error: [{
                type: Output
            }], isActive: [{
                type: HostBinding,
                args: ['class.g-active-thumb']
            }], isIndexAttr: [{
                type: HostBinding,
                args: ['attr.galleryIndex']
            }] } });

class ThumbResizeObserver {
    get _viewport() {
        return this._el.nativeElement;
    }
    constructor(_el, _zone) {
        this._el = _el;
        this._zone = _zone;
        this.resized = new EventEmitter();
    }
    ngOnInit() {
        this._zone.runOutsideAngular(() => {
            this._resizeSubscription = resizeObservable(this._viewport).pipe(debounceTime(this.config.resizeDebounceTime, animationFrameScheduler), tap(() => {
                this.updateSliderSize();
                this.resized.emit();
            })).subscribe();
        });
    }
    ngOnChanges(changes) {
        if (!changes.config.firstChange) {
            this.updateSliderSize();
        }
    }
    ngOnDestroy() {
        this._resizeSubscription?.unsubscribe();
    }
    updateSliderSize() {
        this._viewport.style.setProperty('--thumb-centralize-start-size', this.adapter.getCentralizerStartSize() + 'px');
        this._viewport.style.setProperty('--thumb-centralize-end-size', this.adapter.getCentralizerEndSize() + 'px');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: ThumbResizeObserver, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.1", type: ThumbResizeObserver, isStandalone: true, selector: "[thumbResizeObserver]", inputs: { config: "config", adapter: "adapter" }, outputs: { resized: "thumbResizeObserver" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: ThumbResizeObserver, decorators: [{
            type: Directive,
            args: [{
                    selector: '[thumbResizeObserver]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { config: [{
                type: Input
            }], adapter: [{
                type: Input
            }], resized: [{
                type: Output,
                args: ['thumbResizeObserver']
            }] } });

class GalleryThumbsComponent {
    constructor() {
        /** Stream that emits the slider position */
        this.position$ = new Subject();
        /** Stream that emits when thumb is clicked */
        this.thumbClick = new EventEmitter();
        /** Stream that emits when an error occurs */
        this.error = new EventEmitter();
        this.items = new QueryList();
    }
    get slider() {
        return this.sliderEl.nativeElement;
    }
    ngOnChanges(changes) {
        if (changes.config) {
            // Sets sliding direction
            if (changes.config.currentValue?.thumbPosition !== changes.config.previousValue?.thumbPosition) {
                switch (this.config.thumbPosition) {
                    case ThumbnailsPosition.Right:
                    case ThumbnailsPosition.Left:
                        this.adapter = new VerticalAdapter(this.slider, this.config);
                        break;
                    case ThumbnailsPosition.Top:
                    case ThumbnailsPosition.Bottom:
                        this.adapter = new HorizontalAdapter(this.slider, this.config);
                        break;
                }
                if (!changes.config.firstChange) {
                    // Keep the correct sliding position when direction changes
                    requestAnimationFrame(() => {
                        this.scrollToIndex(this.state.currIndex, 'auto');
                    });
                }
            }
        }
        if (changes.state && (changes.state.firstChange || !this.config.detachThumbs)) {
            if (changes.state.currentValue?.currIndex !== changes.state.previousValue?.currIndex) {
                // Scroll slide to item when current index changes.
                requestAnimationFrame(() => {
                    this.scrollToIndex(this.state.currIndex, changes.state?.firstChange ? 'auto' : 'smooth');
                });
            }
        }
    }
    ngAfterViewInit() {
        this.items.notifyOnChanges();
        this.items$ = this.items.changes.pipe(
        // In some cases, items is not notified at first, need to force start the stream
        startWith(null), map(() => this.items.toArray()));
    }
    trackByFn(index, item) {
        return item.type;
    }
    onActiveIndexChange(index) {
        if (index === -1) {
            // Reset active index position
            this.scrollToIndex(this.state.currIndex, 'smooth');
        }
        else {
            this.scrollToIndex(index, 'smooth');
        }
    }
    scrollToIndex(value, behavior) {
        const el = this.items.get(value)?.nativeElement;
        if (el) {
            const pos = this.adapter.getScrollToValue(el, behavior);
            this.position$.next(pos);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryThumbsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.1", type: GalleryThumbsComponent, isStandalone: true, selector: "gallery-thumbs", inputs: { galleryId: "galleryId", state: "state", config: "config" }, outputs: { thumbClick: "thumbClick", error: "error" }, viewQueries: [{ propertyName: "sliderEl", first: true, predicate: ["slider"], descendants: true, static: true }, { propertyName: "items", predicate: GalleryThumbComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div #slider
         class="g-slider"
         [smoothScroll]="position$ | async"
         [smoothScrollInterruptOnMousemove]="!config.disableThumbMouseScroll"
         [attr.centralised]="config.thumbCentralized || adapter.isContentLessThanContainer"
         [hammerSliding]="!config.disableThumbMouseScroll"
         [galleryId]="galleryId"
         [items]="items$ | async"
         [state]="state"
         [config]="config"
         [adapter]="adapter"
         (thumbResizeObserver)="scrollToIndex(state.currIndex, 'auto')"
         (activeIndexChange)="onActiveIndexChange($event)">
      <div class="g-slider-content">
        <gallery-thumb *ngFor="let item of state.items; trackBy: trackByFn; index as i"
                       [attr.galleryId]="galleryId"
                       [type]="item.type"
                       [config]="config"
                       [data]="item.data"
                       [currIndex]="state.currIndex"
                       [index]="i"
                       [count]="state.items.length"
                       (click)="config.disableThumbs ? null : thumbClick.emit(i)"
                       (error)="error.emit({ itemIndex: i, error: $event })"/>
      </div>
    </div>
  `, isInline: true, styles: [":host{max-height:100%;max-width:100%;display:block;z-index:100}.g-slider{display:flex;align-items:center;transition:var(--g-height-transition);max-height:100%;min-width:100%;height:var(--thumb-slider-height);width:var(--thumb-slider-width);top:var(--thumb-slider-top);left:var(--thumb-slider-left);overflow:var(--thumb-slider-overflow);scroll-snap-type:var(--slider-scroll-snap-type);flex-direction:var(--thumb-slider-flex-direction);scrollbar-width:none}.g-slider::-webkit-scrollbar{display:none}.g-slider.g-sliding .g-slider-content{pointer-events:none}.g-slider[centralised=true]:before,.g-slider[centralised=true]:after{content:\"\"}.g-slider[centralised=true]:before{flex:0 0 var(--thumb-centralize-start-size)}.g-slider[centralised=true]:after{flex:0 0 var(--thumb-centralize-end-size)}.g-slider-content{flex:0 0 auto;display:flex;flex-direction:var(--thumb-slider-flex-direction);align-items:center;gap:1px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "pipe", type: i1.AsyncPipe, name: "async" }, { kind: "component", type: GalleryThumbComponent, selector: "gallery-thumb", inputs: ["config", "index", "count", "currIndex", "type", "data"], outputs: ["error"] }, { kind: "directive", type: SmoothScroll, selector: "[smoothScroll]", inputs: ["smoothScroll", "adapter", "config", "smoothScrollInterruptOnMousemove"], outputs: ["isScrollingChange"] }, { kind: "directive", type: HammerSliding, selector: "[hammerSliding]", inputs: ["hammerSliding", "galleryId", "items", "adapter", "state", "config"], outputs: ["activeIndexChange", "isSlidingChange"] }, { kind: "directive", type: ThumbResizeObserver, selector: "[thumbResizeObserver]", inputs: ["config", "adapter"], outputs: ["thumbResizeObserver"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryThumbsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'gallery-thumbs', changeDetection: ChangeDetectionStrategy.OnPush, template: `
    <div #slider
         class="g-slider"
         [smoothScroll]="position$ | async"
         [smoothScrollInterruptOnMousemove]="!config.disableThumbMouseScroll"
         [attr.centralised]="config.thumbCentralized || adapter.isContentLessThanContainer"
         [hammerSliding]="!config.disableThumbMouseScroll"
         [galleryId]="galleryId"
         [items]="items$ | async"
         [state]="state"
         [config]="config"
         [adapter]="adapter"
         (thumbResizeObserver)="scrollToIndex(state.currIndex, 'auto')"
         (activeIndexChange)="onActiveIndexChange($event)">
      <div class="g-slider-content">
        <gallery-thumb *ngFor="let item of state.items; trackBy: trackByFn; index as i"
                       [attr.galleryId]="galleryId"
                       [type]="item.type"
                       [config]="config"
                       [data]="item.data"
                       [currIndex]="state.currIndex"
                       [index]="i"
                       [count]="state.items.length"
                       (click)="config.disableThumbs ? null : thumbClick.emit(i)"
                       (error)="error.emit({ itemIndex: i, error: $event })"/>
      </div>
    </div>
  `, standalone: true, imports: [CommonModule, GalleryThumbComponent, SmoothScroll, HammerSliding, ThumbResizeObserver], styles: [":host{max-height:100%;max-width:100%;display:block;z-index:100}.g-slider{display:flex;align-items:center;transition:var(--g-height-transition);max-height:100%;min-width:100%;height:var(--thumb-slider-height);width:var(--thumb-slider-width);top:var(--thumb-slider-top);left:var(--thumb-slider-left);overflow:var(--thumb-slider-overflow);scroll-snap-type:var(--slider-scroll-snap-type);flex-direction:var(--thumb-slider-flex-direction);scrollbar-width:none}.g-slider::-webkit-scrollbar{display:none}.g-slider.g-sliding .g-slider-content{pointer-events:none}.g-slider[centralised=true]:before,.g-slider[centralised=true]:after{content:\"\"}.g-slider[centralised=true]:before{flex:0 0 var(--thumb-centralize-start-size)}.g-slider[centralised=true]:after{flex:0 0 var(--thumb-centralize-end-size)}.g-slider-content{flex:0 0 auto;display:flex;flex-direction:var(--thumb-slider-flex-direction);align-items:center;gap:1px}\n"] }]
        }], propDecorators: { galleryId: [{
                type: Input
            }], state: [{
                type: Input
            }], config: [{
                type: Input
            }], thumbClick: [{
                type: Output
            }], error: [{
                type: Output
            }], sliderEl: [{
                type: ViewChild,
                args: ['slider', { static: true }]
            }], items: [{
                type: ViewChildren,
                args: [GalleryThumbComponent]
            }] } });

class GalleryCoreComponent {
    /** Set thumbnails position */
    get thumbPosition() {
        return this.config.thumbPosition;
    }
    /** Set sliding direction */
    get orientation() {
        return this.config.orientation;
    }
    /** Disable thumbnails' clicks */
    get disableThumb() {
        return this.config.disableThumbs;
    }
    /** Set bullets' clicks */
    get bulletDisabled() {
        return this.config.disableBullets;
    }
    /** Set gallery bullets position */
    get bulletPosition() {
        return this.config.bulletPosition;
    }
    /** Set gallery image size property */
    get imageSize() {
        return this.config.imageSize;
    }
    /** Set gallery thumb image size property */
    get thumbImageSize() {
        return this.config.thumbImageSize;
    }
    /** Set gallery counter position */
    get counterPosition() {
        return this.config.counterPosition;
    }
    /** Disable sliding using sliding via touchpad, mousewheel and gestures */
    get scrollDisabled() {
        return this.config.disableScroll;
    }
    /** Disable thumb sliding using sliding via touchpad, mousewheel and gestures */
    get thumbScrollDisabled() {
        return this.config.disableThumbScroll;
    }
    /** Set items autosize styles  */
    get itemAutosize() {
        return this.config.itemAutosize;
    }
    /** Set gallery autoHeight styles  */
    get autoHeight() {
        return this.config.autoHeight;
    }
    /** Set gallery thumb autosize styles  */
    get thumbAutosize() {
        return this.config.thumbAutosize;
    }
    /** Set direction  */
    get direction() {
        return this.dir.value;
    }
    /** Set debug style  */
    get debug() {
        return this.config.debug;
    }
    constructor(el, dir) {
        this.el = el;
        this.dir = dir;
        this.itemClick = new EventEmitter();
        this.thumbClick = new EventEmitter();
        this.error = new EventEmitter();
    }
    ngOnChanges(changes) {
        if (changes.config) {
            if (changes.config.currentValue?.thumbWidth !== changes.config.previousValue?.thumbWidth) {
                this.el.nativeElement.style.setProperty('--g-thumb-width', coerceCssPixelValue(changes.config.currentValue.thumbWidth));
            }
            if (changes.config.currentValue?.thumbHeight !== changes.config.previousValue?.thumbHeight) {
                this.el.nativeElement.style.setProperty('--g-thumb-height', coerceCssPixelValue(changes.config.currentValue.thumbHeight));
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryCoreComponent, deps: [{ token: i0.ElementRef }, { token: i1$2.Directionality }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.1", type: GalleryCoreComponent, isStandalone: true, selector: "gallery-core", inputs: { galleryId: "galleryId", state: "state", config: "config" }, outputs: { itemClick: "itemClick", thumbClick: "thumbClick", error: "error" }, host: { properties: { "attr.thumbPosition": "this.thumbPosition", "attr.orientation": "this.orientation", "attr.thumbDisabled": "this.disableThumb", "attr.bulletDisabled": "this.bulletDisabled", "attr.bulletPosition": "this.bulletPosition", "attr.imageSize": "this.imageSize", "attr.thumbImageSize": "this.thumbImageSize", "attr.counterPosition": "this.counterPosition", "attr.scrollDisabled": "this.scrollDisabled", "attr.thumbScrollDisabled": "this.thumbScrollDisabled", "attr.itemAutosize": "this.itemAutosize", "attr.autoHeight": "this.autoHeight", "attr.thumbAutosize": "this.thumbAutosize", "attr.dir": "this.direction", "attr.debug": "this.debug" } }, usesOnChanges: true, ngImport: i0, template: `
    <gallery-thumbs *ngIf="config.thumbs"
                    [state]="state"
                    [config]="config"
                    [galleryId]="galleryId"
                    (thumbClick)="thumbClick.emit($event)"
                    (error)="error.emit($event)"/>

    <div class="g-box">
      <gallery-slider [class.g-debug]="config.debug"
                      [state]="state"
                      [config]="config"
                      [galleryId]="galleryId"
                      (itemClick)="itemClick.emit($event)"
                      (error)="error.emit($event)">

        <gallery-nav *ngIf="config.nav && state.items.length > 1"
                     [state]="state"
                     [config]="config"
                     [galleryId]="galleryId"/>

      </gallery-slider>

      <gallery-bullets *ngIf="config.bullets"
                       [state]="state"
                       [config]="config"
                       [galleryId]="galleryId"/>

      <gallery-counter *ngIf="config.counter"
                       [state]="state"/>

      <div class="g-box-template">
        <ng-container
          *ngTemplateOutlet="config.boxTemplate; context: { state: state, config: config }"></ng-container>
      </div>
    </div>
  `, isInline: true, styles: [":host{position:relative;overflow:hidden;display:flex;gap:var(--g-gutter-size);width:100%;height:500px;min-height:100%;max-height:100%;--image-object-fit: unset;--slider-thumb-height: unset;--slider-thumb-width: unset;--thumb-slider-left: unset;--thumb-slider-overflow: unset;--thumb-slider-flex-direction: unset;--g-thumb-width: unset;--g-thumb-height: unset;--g-thumb-cursor: pointer;--slider-scroll-snap-type: unset;--slider-overflow: unset;--slider-flex-direction: unset;--slider-width: unset;--slider-height: unset;--slider-content-width: unset;--slider-content-height: unset;--g-item-width: unset;--g-item-height: unset;--g-item-max-height: var(--slider-height);--bullets-top: unset;--bullets-bottom: unset;--bullets-cursor: pointer;--bullets-opacity: .4;--bullets-hover-opacity: 1;--bullets-active-opacity: 1;--counter-top: unset;--counter-bottom: unset;--counter-border-radius: unset;--nav-space: 8px;--nav-hover-space: 6.4px;--nav-next-right: unset;--nav-next-hover-right: unset;--nav-next-left: unset;--nav-next-hover-left: unset}:host[thumbPosition=top]{flex-direction:column}:host[thumbPosition=left]{flex-direction:row}:host[thumbPosition=right]{flex-direction:row-reverse}:host[thumbPosition=bottom]{flex-direction:column-reverse}:host[autoHeight=true][itemAutoSize=false][orientation=horizontal][thumbPosition=top],:host[autoHeight=true][itemAutoSize=false][orientation=horizontal][thumbPosition=bottom]{height:fit-content;--g-item-height: auto !important;--g-item-max-height: auto}:host[imageSize=contain] gallery-slider,:host[thumbImageSize=contain] gallery-thumbs{--image-object-fit: contain}:host[imageSize=cover] gallery-slider,:host[thumbImageSize=cover] gallery-thumbs{--image-object-fit: cover}:host[thumbPosition=top],:host[thumbPosition=bottom]{--thumb-slider-top: 0;--thumb-slider-overflow: auto hidden;--thumb-slider-flex-direction: row;--g-thumb-height: 100%}:host[thumbPosition=top][thumbAutosize=true],:host[thumbPosition=bottom][thumbAutosize=true]{--g-thumb-width: auto !important}:host[thumbPosition=left],:host[thumbPosition=right]{--thumb-slider-left: 0;--thumb-slider-overflow: hidden auto;--thumb-slider-flex-direction: column;--g-thumb-width: 100%}:host[thumbPosition=left][thumbAutosize=true],:host[thumbPosition=right][thumbAutosize=true]{--g-thumb-height: auto !important}:host[thumbDisbled=true]{--g-thumb-cursor: default}:host[thumbScrollDisabled=true]{--thumb-slider-overflow: hidden !important}:host[orientation=horizontal]{--slider-overflow: auto hidden;--slider-scroll-snap-type: x mandatory;--slider-flex-direction: row;--slider-content-height: 100%}:host[orientation=vertical]{--slider-overflow: hidden auto;--slider-scroll-snap-type: y mandatory;--slider-flex-direction: column;--slider-content-width: 100%}:host[scrollDisabled=true]{--slider-overflow: hidden !important}:host[orientation=horizontal]{--g-item-width: var(--slider-width);--g-item-height: 100%}:host[orientation=horizontal][itemAutoSize=true]{--g-item-width: auto}:host[orientation=vertical]{--g-item-width: 100%;--g-item-height: var(--slider-height)}:host[orientation=vertical][itemAutoSize=true]{--g-item-height: auto}:host[bulletPosition=top]{--bullets-top: 15px}:host[bulletPosition=bottom]{--bullets-bottom: 15px}:host[bulletDisabled=true]{--bullets-cursor: default;--bullets-hover-opacity: var(--bullets-opacity)}:host[counterPosition=top]{--counter-top: 0;--counter-border-radius: 0 0 4px 4px}:host[counterPosition=bottom]{--counter-bottom: 0;--counter-border-radius: 4px 4px 0 0}:host[dir=ltr]{--nav-next-transform: translateY(-50%) perspective(1px);--nav-next-right: var(--nav-space);--nav-next-hover-right: var(--nav-hover-space);--nav-prev-transform: translateY(-50%) perspective(1px) scale(-1, -1);--nav-prev-left: var(--nav-space);--nav-prev-hover-left: var(--nav-hover-space)}:host[dir=rtl]{--nav-next-transform: translateY(-50%) perspective(1px) scale(-1, -1);--nav-next-left: var(--nav-space);--nav-next-hover-left: var(--nav-hover-space);--nav-prev-transform: translateY(-50%) perspective(1px);--nav-prev-right: var(--nav-space);--nav-prev-hover-right: var(--nav-hover-space)}.g-box{overflow:hidden;position:relative;display:flex;flex-direction:column;order:1;flex:1}.g-box-template{position:absolute;z-index:10}\n", ":host[debug=true] ::ng-deep .g-sliding gallery-item.g-item-highlight,:host[debug=true] ::ng-deep .g-resizing gallery-item.g-item-highlight,:host[debug=true] ::ng-deep .g-scrolling gallery-item.g-item-highlight{visibility:hidden}:host[debug=true] ::ng-deep gallery-slider:after,:host[debug=true] ::ng-deep gallery-slider:before{position:absolute;content:\"\";z-index:12}:host[debug=true] ::ng-deep gallery-slider:before{width:100%;height:0;border-top:1px dashed lime}:host[debug=true] ::ng-deep gallery-slider:after{height:100%;width:0;border-left:1px dashed lime}:host[debug=true] ::ng-deep gallery-slider gallery-item{outline:1px solid darkorange}:host[debug=true] ::ng-deep gallery-slider gallery-item.g-item-highlight:after{content:\"\";position:absolute;width:100%;height:100%;border:3px solid lime;box-sizing:border-box;z-index:10}:host[debug=true] ::ng-deep .g-sliding .g-slider-sliding{display:block}:host[debug=true] ::ng-deep .g-scrolling .g-slider-scrolling{display:block}:host[debug=true] ::ng-deep .g-resizing .g-slider-resizing{display:block}:host[debug=true] ::ng-deep .g-slider-debug{position:absolute;top:0;left:0;display:flex;gap:5px;padding:10px}:host[debug=true] ::ng-deep .g-slider-debug .g-slider-resizing{background:#f54c28}:host[debug=true] ::ng-deep .g-slider-debug .g-slider-scrolling{background:#ff8524}:host[debug=true] ::ng-deep .g-slider-debug .g-slider-sliding{background:#1f6cb9}:host[debug=true] ::ng-deep .g-slider-debug div,:host[debug=true] ::ng-deep .g-slider-debug:before{display:none;color:#fff;font-family:monospace;z-index:12;padding:2px 6px;border-radius:3px}:host[debug=true][itemAutoSize=false] ::ng-deep .g-slider-debug:before{content:var(--intersection-margin);background:#ecececd6;color:#363636;display:block}:host[debug=true][itemAutoSize=true] ::ng-deep gallery-item:before{position:absolute;margin:10px;content:var(--item-intersection-margin);background:#ecececd6;color:#363636;display:block;width:270px;font-family:monospace;z-index:12;padding:2px 6px;border-radius:3px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: GalleryThumbsComponent, selector: "gallery-thumbs", inputs: ["galleryId", "state", "config"], outputs: ["thumbClick", "error"] }, { kind: "component", type: GallerySliderComponent, selector: "gallery-slider", inputs: ["galleryId", "state", "config"], outputs: ["itemClick", "error"] }, { kind: "component", type: GalleryNavComponent, selector: "gallery-nav", inputs: ["galleryId", "state", "config"] }, { kind: "component", type: GalleryBulletsComponent, selector: "gallery-bullets", inputs: ["galleryId", "state", "config"] }, { kind: "component", type: GalleryCounterComponent, selector: "gallery-counter", inputs: ["state"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryCoreComponent, decorators: [{
            type: Component,
            args: [{ selector: 'gallery-core', changeDetection: ChangeDetectionStrategy.OnPush, template: `
    <gallery-thumbs *ngIf="config.thumbs"
                    [state]="state"
                    [config]="config"
                    [galleryId]="galleryId"
                    (thumbClick)="thumbClick.emit($event)"
                    (error)="error.emit($event)"/>

    <div class="g-box">
      <gallery-slider [class.g-debug]="config.debug"
                      [state]="state"
                      [config]="config"
                      [galleryId]="galleryId"
                      (itemClick)="itemClick.emit($event)"
                      (error)="error.emit($event)">

        <gallery-nav *ngIf="config.nav && state.items.length > 1"
                     [state]="state"
                     [config]="config"
                     [galleryId]="galleryId"/>

      </gallery-slider>

      <gallery-bullets *ngIf="config.bullets"
                       [state]="state"
                       [config]="config"
                       [galleryId]="galleryId"/>

      <gallery-counter *ngIf="config.counter"
                       [state]="state"/>

      <div class="g-box-template">
        <ng-container
          *ngTemplateOutlet="config.boxTemplate; context: { state: state, config: config }"></ng-container>
      </div>
    </div>
  `, standalone: true, imports: [CommonModule, GalleryThumbsComponent, GallerySliderComponent, GalleryNavComponent, GalleryBulletsComponent, GalleryCounterComponent], styles: [":host{position:relative;overflow:hidden;display:flex;gap:var(--g-gutter-size);width:100%;height:500px;min-height:100%;max-height:100%;--image-object-fit: unset;--slider-thumb-height: unset;--slider-thumb-width: unset;--thumb-slider-left: unset;--thumb-slider-overflow: unset;--thumb-slider-flex-direction: unset;--g-thumb-width: unset;--g-thumb-height: unset;--g-thumb-cursor: pointer;--slider-scroll-snap-type: unset;--slider-overflow: unset;--slider-flex-direction: unset;--slider-width: unset;--slider-height: unset;--slider-content-width: unset;--slider-content-height: unset;--g-item-width: unset;--g-item-height: unset;--g-item-max-height: var(--slider-height);--bullets-top: unset;--bullets-bottom: unset;--bullets-cursor: pointer;--bullets-opacity: .4;--bullets-hover-opacity: 1;--bullets-active-opacity: 1;--counter-top: unset;--counter-bottom: unset;--counter-border-radius: unset;--nav-space: 8px;--nav-hover-space: 6.4px;--nav-next-right: unset;--nav-next-hover-right: unset;--nav-next-left: unset;--nav-next-hover-left: unset}:host[thumbPosition=top]{flex-direction:column}:host[thumbPosition=left]{flex-direction:row}:host[thumbPosition=right]{flex-direction:row-reverse}:host[thumbPosition=bottom]{flex-direction:column-reverse}:host[autoHeight=true][itemAutoSize=false][orientation=horizontal][thumbPosition=top],:host[autoHeight=true][itemAutoSize=false][orientation=horizontal][thumbPosition=bottom]{height:fit-content;--g-item-height: auto !important;--g-item-max-height: auto}:host[imageSize=contain] gallery-slider,:host[thumbImageSize=contain] gallery-thumbs{--image-object-fit: contain}:host[imageSize=cover] gallery-slider,:host[thumbImageSize=cover] gallery-thumbs{--image-object-fit: cover}:host[thumbPosition=top],:host[thumbPosition=bottom]{--thumb-slider-top: 0;--thumb-slider-overflow: auto hidden;--thumb-slider-flex-direction: row;--g-thumb-height: 100%}:host[thumbPosition=top][thumbAutosize=true],:host[thumbPosition=bottom][thumbAutosize=true]{--g-thumb-width: auto !important}:host[thumbPosition=left],:host[thumbPosition=right]{--thumb-slider-left: 0;--thumb-slider-overflow: hidden auto;--thumb-slider-flex-direction: column;--g-thumb-width: 100%}:host[thumbPosition=left][thumbAutosize=true],:host[thumbPosition=right][thumbAutosize=true]{--g-thumb-height: auto !important}:host[thumbDisbled=true]{--g-thumb-cursor: default}:host[thumbScrollDisabled=true]{--thumb-slider-overflow: hidden !important}:host[orientation=horizontal]{--slider-overflow: auto hidden;--slider-scroll-snap-type: x mandatory;--slider-flex-direction: row;--slider-content-height: 100%}:host[orientation=vertical]{--slider-overflow: hidden auto;--slider-scroll-snap-type: y mandatory;--slider-flex-direction: column;--slider-content-width: 100%}:host[scrollDisabled=true]{--slider-overflow: hidden !important}:host[orientation=horizontal]{--g-item-width: var(--slider-width);--g-item-height: 100%}:host[orientation=horizontal][itemAutoSize=true]{--g-item-width: auto}:host[orientation=vertical]{--g-item-width: 100%;--g-item-height: var(--slider-height)}:host[orientation=vertical][itemAutoSize=true]{--g-item-height: auto}:host[bulletPosition=top]{--bullets-top: 15px}:host[bulletPosition=bottom]{--bullets-bottom: 15px}:host[bulletDisabled=true]{--bullets-cursor: default;--bullets-hover-opacity: var(--bullets-opacity)}:host[counterPosition=top]{--counter-top: 0;--counter-border-radius: 0 0 4px 4px}:host[counterPosition=bottom]{--counter-bottom: 0;--counter-border-radius: 4px 4px 0 0}:host[dir=ltr]{--nav-next-transform: translateY(-50%) perspective(1px);--nav-next-right: var(--nav-space);--nav-next-hover-right: var(--nav-hover-space);--nav-prev-transform: translateY(-50%) perspective(1px) scale(-1, -1);--nav-prev-left: var(--nav-space);--nav-prev-hover-left: var(--nav-hover-space)}:host[dir=rtl]{--nav-next-transform: translateY(-50%) perspective(1px) scale(-1, -1);--nav-next-left: var(--nav-space);--nav-next-hover-left: var(--nav-hover-space);--nav-prev-transform: translateY(-50%) perspective(1px);--nav-prev-right: var(--nav-space);--nav-prev-hover-right: var(--nav-hover-space)}.g-box{overflow:hidden;position:relative;display:flex;flex-direction:column;order:1;flex:1}.g-box-template{position:absolute;z-index:10}\n", ":host[debug=true] ::ng-deep .g-sliding gallery-item.g-item-highlight,:host[debug=true] ::ng-deep .g-resizing gallery-item.g-item-highlight,:host[debug=true] ::ng-deep .g-scrolling gallery-item.g-item-highlight{visibility:hidden}:host[debug=true] ::ng-deep gallery-slider:after,:host[debug=true] ::ng-deep gallery-slider:before{position:absolute;content:\"\";z-index:12}:host[debug=true] ::ng-deep gallery-slider:before{width:100%;height:0;border-top:1px dashed lime}:host[debug=true] ::ng-deep gallery-slider:after{height:100%;width:0;border-left:1px dashed lime}:host[debug=true] ::ng-deep gallery-slider gallery-item{outline:1px solid darkorange}:host[debug=true] ::ng-deep gallery-slider gallery-item.g-item-highlight:after{content:\"\";position:absolute;width:100%;height:100%;border:3px solid lime;box-sizing:border-box;z-index:10}:host[debug=true] ::ng-deep .g-sliding .g-slider-sliding{display:block}:host[debug=true] ::ng-deep .g-scrolling .g-slider-scrolling{display:block}:host[debug=true] ::ng-deep .g-resizing .g-slider-resizing{display:block}:host[debug=true] ::ng-deep .g-slider-debug{position:absolute;top:0;left:0;display:flex;gap:5px;padding:10px}:host[debug=true] ::ng-deep .g-slider-debug .g-slider-resizing{background:#f54c28}:host[debug=true] ::ng-deep .g-slider-debug .g-slider-scrolling{background:#ff8524}:host[debug=true] ::ng-deep .g-slider-debug .g-slider-sliding{background:#1f6cb9}:host[debug=true] ::ng-deep .g-slider-debug div,:host[debug=true] ::ng-deep .g-slider-debug:before{display:none;color:#fff;font-family:monospace;z-index:12;padding:2px 6px;border-radius:3px}:host[debug=true][itemAutoSize=false] ::ng-deep .g-slider-debug:before{content:var(--intersection-margin);background:#ecececd6;color:#363636;display:block}:host[debug=true][itemAutoSize=true] ::ng-deep gallery-item:before{position:absolute;margin:10px;content:var(--item-intersection-margin);background:#ecececd6;color:#363636;display:block;width:270px;font-family:monospace;z-index:12;padding:2px 6px;border-radius:3px}\n"] }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i1$2.Directionality }], propDecorators: { galleryId: [{
                type: Input
            }], state: [{
                type: Input
            }], config: [{
                type: Input
            }], itemClick: [{
                type: Output
            }], thumbClick: [{
                type: Output
            }], error: [{
                type: Output
            }], thumbPosition: [{
                type: HostBinding,
                args: ['attr.thumbPosition']
            }], orientation: [{
                type: HostBinding,
                args: ['attr.orientation']
            }], disableThumb: [{
                type: HostBinding,
                args: ['attr.thumbDisabled']
            }], bulletDisabled: [{
                type: HostBinding,
                args: ['attr.bulletDisabled']
            }], bulletPosition: [{
                type: HostBinding,
                args: ['attr.bulletPosition']
            }], imageSize: [{
                type: HostBinding,
                args: ['attr.imageSize']
            }], thumbImageSize: [{
                type: HostBinding,
                args: ['attr.thumbImageSize']
            }], counterPosition: [{
                type: HostBinding,
                args: ['attr.counterPosition']
            }], scrollDisabled: [{
                type: HostBinding,
                args: ['attr.scrollDisabled']
            }], thumbScrollDisabled: [{
                type: HostBinding,
                args: ['attr.thumbScrollDisabled']
            }], itemAutosize: [{
                type: HostBinding,
                args: ['attr.itemAutosize']
            }], autoHeight: [{
                type: HostBinding,
                args: ['attr.autoHeight']
            }], thumbAutosize: [{
                type: HostBinding,
                args: ['attr.thumbAutosize']
            }], direction: [{
                type: HostBinding,
                args: ['attr.dir']
            }], debug: [{
                type: HostBinding,
                args: ['attr.debug']
            }] } });

class GalleryImageDef {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    // Make sure the template checker knows the type of the context with which the
    // template of this directive will be rendered
    static ngTemplateContextGuard(directive, context) {
        return true;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryImageDef, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.1", type: GalleryImageDef, isStandalone: true, selector: "[galleryImageDef]", ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryImageDef, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[galleryImageDef]'
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }] });

class GalleryThumbDef {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    // Make sure the template checker knows the type of the context with which the
    // template of this directive will be rendered
    static ngTemplateContextGuard(directive, context) {
        return true;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryThumbDef, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.1", type: GalleryThumbDef, isStandalone: true, selector: "[galleryThumbDef]", ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryThumbDef, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[galleryThumbDef]'
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }] });

class GalleryItemDef {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    // Make sure the template checker knows the type of the context with which the
    // template of this directive will be rendered
    static ngTemplateContextGuard(directive, context) {
        return true;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryItemDef, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.1", type: GalleryItemDef, isStandalone: true, selector: "[galleryItemDef]", ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryItemDef, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[galleryItemDef]'
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }] });

class GalleryBoxDef {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
    // Make sure the template checker knows the type of the context with which the
    // template of this directive will be rendered
    static ngTemplateContextGuard(directive, context) {
        return true;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryBoxDef, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.1", type: GalleryBoxDef, isStandalone: true, selector: "[galleryBoxDef]", ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryBoxDef, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[galleryBoxDef]'
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }] });

class AutoplayDirective {
    constructor(_gallery, _imgManager) {
        this._gallery = _gallery;
        this._imgManager = _imgManager;
    }
    ngAfterViewInit() {
        this._galleryRef = this._gallery.ref(this.galleryId);
        this._subscribe();
        if (this.config.autoplay) {
            this._galleryRef.play();
        }
    }
    ngOnChanges(changes) {
        if (this._galleryRef && changes.config?.currentValue.autoplay !== changes.config?.previousValue.autoplay) {
            this.config.autoplay ? this._galleryRef.play() : this._galleryRef.stop();
        }
    }
    ngOnDestroy() {
        this._unsubscribe();
    }
    _subscribe() {
        this._unsubscribe();
        this._currentSubscription = this._galleryRef.playingChanged.pipe(switchMap((state) => {
            if (state.isPlaying) {
                return this._imgManager.getActiveItem(this._galleryRef.state).pipe(switchMap(() => of({}).pipe(delay(this.config.autoplayInterval), tap(() => {
                    if (this._galleryRef.stateSnapshot.hasNext) {
                        this._galleryRef.next(this.config.scrollBehavior);
                    }
                    else {
                        this._galleryRef.set(0, this.config.scrollBehavior);
                    }
                }))));
            }
            return EMPTY;
        })).subscribe();
    }
    _unsubscribe() {
        this._currentSubscription?.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: AutoplayDirective, deps: [{ token: Gallery }, { token: ImgManager }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.1", type: AutoplayDirective, isStandalone: true, selector: "gallery-core[autoplay]", inputs: { config: "config", galleryId: "galleryId" }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: AutoplayDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'gallery-core[autoplay]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: Gallery }, { type: ImgManager }], propDecorators: { config: [{
                type: Input
            }], galleryId: [{
                type: Input
            }] } });

/**
 * Gallery component
 */
class GalleryComponent {
    constructor(_gallery) {
        this._gallery = _gallery;
        /**
         * The gallery instance unique id, required if more multiple gallery instances
         */
        this.id = 'root';
        /**
         * Displays the navigation buttons
         */
        this.nav = this._gallery.config.nav;
        /**
         * Displays the navigation bullets
         */
        this.bullets = this._gallery.config.bullets;
        /**
         * Enables loop cycling
         */
        this.loop = this._gallery.config.loop;
        /**
         * Show visuals that helps debugging the component
         */
        this.debug = this._gallery.config.debug;
        /**
         * Displays the thumbnails
         */
        this.thumbs = this._gallery.config.thumbs;
        /**
         * Displays the counter or pagination
         */
        this.counter = this._gallery.config.counter;
        /**
         * De-attaching the thumbnails from the main slider
         * If enabled - thumbnails won't automatically scroll to the active thumbnails
         */
        this.detachThumbs = this._gallery.config.detachThumbs;
        /**
         * Fits each thumbnail size to its content
         */
        this.thumbAutosize = this._gallery.config.thumbAutosize;
        /**
         * Fits each item size to its content, This option should be used with:
         * - Does not work if `autoHeight` is turned on
         * - Does not work properly unless `loadingAttr="eager"`
         * - Does not work properly unless `loadingStrategy="preload"`
         */
        this.itemAutosize = this._gallery.config.itemAutosize;
        /**
         * Automatically adjusts the gallery's height to fit the content
         */
        this.autoHeight = this._gallery.config.autoHeight;
        /**
         * Automatically cycle through items at time interval
         */
        this.autoplay = this._gallery.config.autoplay;
        /**
         * Disables thumbnails' clicks
         */
        this.disableThumbs = this._gallery.config.disableThumbs;
        /**
         * Disables bullets' clicks
         */
        this.disableBullets = this._gallery.config.disableBullets;
        /**
         * Disables sliding using mousewheel, touchpad, scroll and gestures on touch devices
         */
        this.disableScroll = this._gallery.config.disableScroll;
        /**
         * Disables sliding of thumbnails using touchpad, scroll and gestures on touch devices
         */
        this.disableThumbScroll = this._gallery.config.disableThumbScroll;
        /**
         * Force centralizing the active thumbnail
         */
        this.thumbCentralized = this._gallery.config.thumbCentralized;
        /**
         * Disables sliding using the mouse
         */
        this.disableMouseScroll = this._gallery.config.disableMouseScroll;
        /**
         * Disables sliding of thumbnails using the mouse
         */
        this.disableThumbMouseScroll = this._gallery.config.disableThumbMouseScroll;
        /**
         * Sets the size of the bullets navigation
         */
        this.bulletSize = this._gallery.config.bulletSize;
        /**
         * Sets the thumbnail's width
         */
        this.thumbWidth = this._gallery.config.thumbWidth;
        /**
         * Sets the thumbnail's height
         */
        this.thumbHeight = this._gallery.config.thumbHeight;
        /**
         * Sets the interval used for the autoplay feature
         */
        this.autoplayInterval = this._gallery.config.autoplayInterval;
        /**
         * Sets the duration used for smooth navigation between the items
         */
        this.scrollDuration = this._gallery.config.scrollDuration;
        /**
         * Sets the debounce time used to throttle the gallery update after it is resized
         */
        this.resizeDebounceTime = this._gallery.config.resizeDebounceTime;
        /**
         * Sets the scroll behavior when the active item is changed
         */
        this.scrollBehavior = this._gallery.config.scrollBehavior;
        /**
         * Sets the ease function used for smooth navigation between the items
         */
        this.scrollEase = this._gallery.config.scrollEase;
        /**
         * Sets the object-fit style applied on items' images
         */
        this.imageSize = this._gallery.config.imageSize;
        /**
         * Sets the object-fit style applied on thumbnails' images
         */
        this.thumbImageSize = this._gallery.config.thumbImageSize;
        /**
         * Sets the bullets navigation position
         */
        this.bulletPosition = this._gallery.config.bulletPosition;
        /**
         * Sets the counter navigation position
         */
        this.counterPosition = this._gallery.config.counterPosition;
        /**
         * Sets the sliding direction
         */
        this.orientation = this._gallery.config.orientation;
        /**
         * Sets the loading attribute applied on the items' images
         */
        this.loadingAttr = this._gallery.config.loadingAttr;
        /**
         * Sets the loading strategy used for displaying the items
         * - `lazy` renders only the active item
         * - `default` renders only the active item, the previous item and the next item
         * - `preload` renders all the items, this option is required for `thumbAutoSize` is enabled
         */
        this.loadingStrategy = this._gallery.config.loadingStrategy;
        /**
         * Sets the thumbnails position, it also sets the sliding direction of the thumbnails accordingly
         */
        this.thumbPosition = this._gallery.config.thumbPosition;
        /**
         * Destroy gallery ref on component destroy event
         * This intended to be used and disabled from the lightbox component
         * @ignore
         * */
        this.destroyRef = true;
        /**
         * Skip initializing the config with components inputs (Lightbox mode)
         * This intended to be used and enabled from the lightbox component
         * @ignore
         */
        this.skipInitConfig = false;
        /**
         * Stream that emits when an item is clicked
         */
        this.itemClick = new EventEmitter();
        /**
         * Stream that emits when a thumbnail is clicked
         */
        this.thumbClick = new EventEmitter();
        /**
         * Stream that emits when player state is changed
         */
        this.playingChange = new EventEmitter();
        /**
         * Stream that emits when index is changed
         */
        this.indexChange = new EventEmitter();
        /**
         * Stream that emits when items array is changed
         */
        this.itemsChange = new EventEmitter();
        /**
         * Stream that emits when an error occurs, this would emit for loading errors of image and video items only
         */
        this.error = new EventEmitter();
    }
    /** @ignore */
    getConfig() {
        return {
            nav: this.nav,
            bullets: this.bullets,
            loop: this.loop,
            debug: this.debug,
            thumbs: this.thumbs,
            counter: this.counter,
            autoplay: this.autoplay,
            bulletSize: this.bulletSize,
            imageSize: this.imageSize,
            thumbImageSize: this.thumbImageSize,
            scrollBehavior: this.scrollBehavior,
            thumbCentralized: this.thumbCentralized,
            thumbWidth: this.thumbWidth,
            thumbHeight: this.thumbHeight,
            scrollEase: this.scrollEase,
            bulletPosition: this.bulletPosition,
            loadingAttr: this.loadingAttr,
            detachThumbs: this.detachThumbs,
            thumbPosition: this.thumbPosition,
            autoplayInterval: this.autoplayInterval,
            counterPosition: this.counterPosition,
            loadingStrategy: this.loadingStrategy,
            scrollDuration: this.scrollDuration,
            orientation: this.orientation,
            resizeDebounceTime: this.resizeDebounceTime,
            disableBullets: this.disableBullets,
            disableThumbs: this.disableThumbs,
            disableScroll: this.disableScroll,
            disableThumbScroll: this.disableThumbScroll,
            disableMouseScroll: this.disableMouseScroll,
            disableThumbMouseScroll: this.disableThumbMouseScroll,
            thumbAutosize: this.thumbAutosize,
            itemAutosize: this.itemAutosize,
            autoHeight: this.autoHeight
        };
    }
    /** @ignore */
    ngOnChanges(changes) {
        if (this.galleryRef) {
            this.galleryRef.setConfig(this.getConfig());
            if (changes.items && changes.items.currentValue !== changes.items.previousValue) {
                this.load(this.items);
            }
        }
    }
    /** @ignore */
    ngOnInit() {
        // Get gallery instance by id
        if (this.skipInitConfig) {
            this.galleryRef = this._gallery.ref(this.id);
        }
        else {
            this.galleryRef = this._gallery.ref(this.id, this.getConfig());
        }
        // Load gallery items
        this.load(this.items);
        // Subscribes to events on demand
        if (this.indexChange.observed) {
            this._indexChange$ = this.galleryRef.indexChanged.subscribe((state) => this.indexChange.emit(state));
        }
        if (this.itemsChange.observed) {
            this._itemChange$ = this.galleryRef.itemsChanged.subscribe((state) => this.itemsChange.emit(state));
        }
        if (this.playingChange.observed) {
            this._playingChange$ = this.galleryRef.playingChanged.subscribe((state) => this.playingChange.emit(state));
        }
    }
    /** @ignore */
    ngAfterContentInit() {
        const templateConfig = {};
        if (this._galleryItemDef) {
            templateConfig.itemTemplate = this._galleryItemDef.templateRef;
        }
        if (this._galleryImageDef) {
            templateConfig.imageTemplate = this._galleryImageDef.templateRef;
        }
        if (this._galleryThumbDef) {
            templateConfig.thumbTemplate = this._galleryThumbDef.templateRef;
        }
        if (this._galleryBoxDef) {
            templateConfig.boxTemplate = this._galleryBoxDef.templateRef;
        }
        if (Object.keys(templateConfig).length) {
            this.galleryRef.setConfig(templateConfig);
        }
    }
    /** @ignore */
    ngOnDestroy() {
        this._itemClick$?.unsubscribe();
        this._thumbClick$?.unsubscribe();
        this._itemChange$?.unsubscribe();
        this._indexChange$?.unsubscribe();
        this._playingChange$?.unsubscribe();
        if (this.destroyRef) {
            this.galleryRef?.destroy();
        }
    }
    /** @ignore */
    onItemClick(i) {
        this.itemClick.emit(i);
        this.galleryRef.itemClick.next(i);
    }
    /** @ignore */
    onThumbClick(i) {
        this.galleryRef.set(i);
        this.thumbClick.emit(i);
        this.galleryRef.thumbClick.next(i);
    }
    /** @ignore */
    onError(err) {
        this.error.emit(err);
        this.galleryRef.error.next(err);
    }
    /**
     * Load items and reset the state
     */
    load(items) {
        this.galleryRef.load(items);
    }
    /**
     * Add gallery item, it can be any item, suitable to add item with a custom template
     */
    add(item, active) {
        this.galleryRef.add(item, active);
    }
    /**
     * Add image item
     */
    addImage(data, active) {
        this.galleryRef.addImage(data, active);
    }
    /**
     * Add video item
     */
    addVideo(data, active) {
        this.galleryRef.addVideo(data, active);
    }
    /**
     * Add iframe item
     */
    addIframe(data, active) {
        this.galleryRef.addIframe(data, active);
    }
    /**
     * Add Youtube item
     */
    addYoutube(data, active) {
        this.galleryRef.addYoutube(data, active);
    }
    /**
     * Add Vimeo item
     */
    addVimeo(data, active) {
        this.galleryRef.addVimeo(data, active);
    }
    /**
     * Remove gallery item by index
     */
    remove(i) {
        this.galleryRef.remove(i);
    }
    /**
     * Go to next item
     */
    next(behavior, loop) {
        this.galleryRef.next(behavior, loop);
    }
    /**
     * Go to prev item
     */
    prev(behavior, loop) {
        this.galleryRef.prev(behavior, loop);
    }
    /**
     * Set active item
     */
    set(i, behavior) {
        this.galleryRef.set(i, behavior);
    }
    /**
     * Reset to initial state
     */
    reset() {
        this.galleryRef.reset();
    }
    /**
     * Start the player
     */
    play(interval) {
        this.galleryRef.play(interval);
    }
    /**
     * Stop the player
     */
    stop() {
        this.galleryRef.stop();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryComponent, deps: [{ token: Gallery }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "18.2.1", type: GalleryComponent, isStandalone: true, selector: "gallery", inputs: { id: "id", items: "items", nav: ["nav", "nav", booleanAttribute], bullets: ["bullets", "bullets", booleanAttribute], loop: ["loop", "loop", booleanAttribute], debug: ["debug", "debug", booleanAttribute], thumbs: ["thumbs", "thumbs", booleanAttribute], counter: ["counter", "counter", booleanAttribute], detachThumbs: ["detachThumbs", "detachThumbs", booleanAttribute], thumbAutosize: ["thumbAutosize", "thumbAutosize", booleanAttribute], itemAutosize: ["itemAutosize", "itemAutosize", booleanAttribute], autoHeight: ["autoHeight", "autoHeight", booleanAttribute], autoplay: ["autoplay", "autoplay", booleanAttribute], disableThumbs: ["disableThumbs", "disableThumbs", booleanAttribute], disableBullets: ["disableBullets", "disableBullets", booleanAttribute], disableScroll: ["disableScroll", "disableScroll", booleanAttribute], disableThumbScroll: ["disableThumbScroll", "disableThumbScroll", booleanAttribute], thumbCentralized: ["thumbCentralized", "thumbCentralized", booleanAttribute], disableMouseScroll: ["disableMouseScroll", "disableMouseScroll", booleanAttribute], disableThumbMouseScroll: ["disableThumbMouseScroll", "disableThumbMouseScroll", booleanAttribute], bulletSize: ["bulletSize", "bulletSize", numberAttribute], thumbWidth: ["thumbWidth", "thumbWidth", numberAttribute], thumbHeight: ["thumbHeight", "thumbHeight", numberAttribute], autoplayInterval: ["autoplayInterval", "autoplayInterval", numberAttribute], scrollDuration: ["scrollDuration", "scrollDuration", numberAttribute], resizeDebounceTime: ["resizeDebounceTime", "resizeDebounceTime", numberAttribute], scrollBehavior: "scrollBehavior", scrollEase: "scrollEase", imageSize: "imageSize", thumbImageSize: "thumbImageSize", bulletPosition: "bulletPosition", counterPosition: "counterPosition", orientation: "orientation", loadingAttr: "loadingAttr", loadingStrategy: "loadingStrategy", thumbPosition: "thumbPosition", destroyRef: "destroyRef", skipInitConfig: "skipInitConfig" }, outputs: { itemClick: "itemClick", thumbClick: "thumbClick", playingChange: "playingChange", indexChange: "indexChange", itemsChange: "itemsChange", error: "error" }, providers: [ImgManager], queries: [{ propertyName: "_galleryItemDef", first: true, predicate: GalleryItemDef, descendants: true }, { propertyName: "_galleryImageDef", first: true, predicate: GalleryImageDef, descendants: true }, { propertyName: "_galleryThumbDef", first: true, predicate: GalleryThumbDef, descendants: true }, { propertyName: "_galleryBoxDef", first: true, predicate: GalleryBoxDef, descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <gallery-core autoplay
                  [galleryId]="id"
                  [state]="galleryRef.state | async"
                  [config]="galleryRef.config | async"
                  (itemClick)="onItemClick($event)"
                  (thumbClick)="onThumbClick($event)"
                  (error)="onError($event)"/>
  `, isInline: true, styles: [":host{position:relative;overflow:hidden;z-index:1;display:flex;justify-content:center;align-items:center;background-color:#000;--g-height-transition: height 468ms cubic-bezier(.42, 0, .58, 1);--g-nav-drop-shadow: drop-shadow(0 0 2px rgba(0, 0, 0, .6));--g-box-shadow: 0 0 3px rgba(0, 0, 0, .6);--g-font-color: #000;--g-overlay-color: #fff;--g-gutter-size: 1px}:host[gallerize]{--g-item-cursor: pointer}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "pipe", type: i1.AsyncPipe, name: "async" }, { kind: "component", type: GalleryCoreComponent, selector: "gallery-core", inputs: ["galleryId", "state", "config"], outputs: ["itemClick", "thumbClick", "error"] }, { kind: "directive", type: AutoplayDirective, selector: "gallery-core[autoplay]", inputs: ["config", "galleryId"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryComponent, decorators: [{
            type: Component,
            args: [{ selector: 'gallery', changeDetection: ChangeDetectionStrategy.OnPush, template: `
    <gallery-core autoplay
                  [galleryId]="id"
                  [state]="galleryRef.state | async"
                  [config]="galleryRef.config | async"
                  (itemClick)="onItemClick($event)"
                  (thumbClick)="onThumbClick($event)"
                  (error)="onError($event)"/>
  `, standalone: true, imports: [CommonModule, GalleryCoreComponent, AutoplayDirective], providers: [ImgManager], styles: [":host{position:relative;overflow:hidden;z-index:1;display:flex;justify-content:center;align-items:center;background-color:#000;--g-height-transition: height 468ms cubic-bezier(.42, 0, .58, 1);--g-nav-drop-shadow: drop-shadow(0 0 2px rgba(0, 0, 0, .6));--g-box-shadow: 0 0 3px rgba(0, 0, 0, .6);--g-font-color: #000;--g-overlay-color: #fff;--g-gutter-size: 1px}:host[gallerize]{--g-item-cursor: pointer}\n"] }]
        }], ctorParameters: () => [{ type: Gallery }], propDecorators: { id: [{
                type: Input
            }], items: [{
                type: Input
            }], nav: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], bullets: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], loop: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], debug: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], thumbs: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], counter: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], detachThumbs: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], thumbAutosize: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], itemAutosize: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], autoHeight: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], autoplay: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disableThumbs: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disableBullets: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disableScroll: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disableThumbScroll: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], thumbCentralized: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disableMouseScroll: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disableThumbMouseScroll: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], bulletSize: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], thumbWidth: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], thumbHeight: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], autoplayInterval: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], scrollDuration: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], resizeDebounceTime: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], scrollBehavior: [{
                type: Input
            }], scrollEase: [{
                type: Input
            }], imageSize: [{
                type: Input
            }], thumbImageSize: [{
                type: Input
            }], bulletPosition: [{
                type: Input
            }], counterPosition: [{
                type: Input
            }], orientation: [{
                type: Input
            }], loadingAttr: [{
                type: Input
            }], loadingStrategy: [{
                type: Input
            }], thumbPosition: [{
                type: Input
            }], destroyRef: [{
                type: Input
            }], skipInitConfig: [{
                type: Input
            }], itemClick: [{
                type: Output
            }], thumbClick: [{
                type: Output
            }], playingChange: [{
                type: Output
            }], indexChange: [{
                type: Output
            }], itemsChange: [{
                type: Output
            }], error: [{
                type: Output
            }], _galleryItemDef: [{
                type: ContentChild,
                args: [GalleryItemDef]
            }], _galleryImageDef: [{
                type: ContentChild,
                args: [GalleryImageDef]
            }], _galleryThumbDef: [{
                type: ContentChild,
                args: [GalleryThumbDef]
            }], _galleryBoxDef: [{
                type: ContentChild,
                args: [GalleryBoxDef]
            }] } });

class GalleryModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.2.1", ngImport: i0, type: GalleryModule, imports: [GalleryComponent,
            GalleryItemDef,
            GalleryImageDef,
            GalleryThumbDef,
            GalleryBoxDef], exports: [GalleryComponent,
            GalleryItemDef,
            GalleryImageDef,
            GalleryThumbDef,
            GalleryBoxDef] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryModule, imports: [GalleryComponent] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        GalleryComponent,
                        GalleryItemDef,
                        GalleryImageDef,
                        GalleryThumbDef,
                        GalleryBoxDef
                    ],
                    exports: [
                        GalleryComponent,
                        GalleryItemDef,
                        GalleryImageDef,
                        GalleryThumbDef,
                        GalleryBoxDef
                    ]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BulletsPosition, CounterPosition, GALLERY_CONFIG, Gallery, GalleryAction, GalleryBoxDef, GalleryComponent, GalleryIframeComponent, GalleryImageComponent, GalleryImageDef, GalleryItemDef, GalleryItemTypes, GalleryModule, GalleryRef, GalleryThumbDef, GalleryVideoComponent, IframeItem, ImageItem, ImageSize, LoadingAttr, LoadingStrategy, Orientation, ThumbnailsPosition, VideoItem, VimeoItem, YoutubeItem };
//# sourceMappingURL=ng-gallery.mjs.map
