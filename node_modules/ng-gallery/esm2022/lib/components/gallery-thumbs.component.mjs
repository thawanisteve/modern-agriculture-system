import { Component, Input, Output, ViewChild, ViewChildren, EventEmitter, QueryList, ChangeDetectionStrategy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Subject, map, startWith } from 'rxjs';
import { ThumbnailsPosition } from '../models/constants';
import { VerticalAdapter, HorizontalAdapter } from './adapters';
import { SmoothScroll } from '../smooth-scroll';
import { GalleryThumbComponent } from './gallery-thumb.component';
import { HammerSliding } from '../gestures/hammer-sliding.directive';
import { ThumbResizeObserver } from '../observers/thumb-resize-observer.directive';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
export class GalleryThumbsComponent {
    constructor() {
        /** Stream that emits the slider position */
        this.position$ = new Subject();
        /** Stream that emits when thumb is clicked */
        this.thumbClick = new EventEmitter();
        /** Stream that emits when an error occurs */
        this.error = new EventEmitter();
        this.items = new QueryList();
    }
    get slider() {
        return this.sliderEl.nativeElement;
    }
    ngOnChanges(changes) {
        if (changes.config) {
            // Sets sliding direction
            if (changes.config.currentValue?.thumbPosition !== changes.config.previousValue?.thumbPosition) {
                switch (this.config.thumbPosition) {
                    case ThumbnailsPosition.Right:
                    case ThumbnailsPosition.Left:
                        this.adapter = new VerticalAdapter(this.slider, this.config);
                        break;
                    case ThumbnailsPosition.Top:
                    case ThumbnailsPosition.Bottom:
                        this.adapter = new HorizontalAdapter(this.slider, this.config);
                        break;
                }
                if (!changes.config.firstChange) {
                    // Keep the correct sliding position when direction changes
                    requestAnimationFrame(() => {
                        this.scrollToIndex(this.state.currIndex, 'auto');
                    });
                }
            }
        }
        if (changes.state && (changes.state.firstChange || !this.config.detachThumbs)) {
            if (changes.state.currentValue?.currIndex !== changes.state.previousValue?.currIndex) {
                // Scroll slide to item when current index changes.
                requestAnimationFrame(() => {
                    this.scrollToIndex(this.state.currIndex, changes.state?.firstChange ? 'auto' : 'smooth');
                });
            }
        }
    }
    ngAfterViewInit() {
        this.items.notifyOnChanges();
        this.items$ = this.items.changes.pipe(
        // In some cases, items is not notified at first, need to force start the stream
        startWith(null), map(() => this.items.toArray()));
    }
    trackByFn(index, item) {
        return item.type;
    }
    onActiveIndexChange(index) {
        if (index === -1) {
            // Reset active index position
            this.scrollToIndex(this.state.currIndex, 'smooth');
        }
        else {
            this.scrollToIndex(index, 'smooth');
        }
    }
    scrollToIndex(value, behavior) {
        const el = this.items.get(value)?.nativeElement;
        if (el) {
            const pos = this.adapter.getScrollToValue(el, behavior);
            this.position$.next(pos);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryThumbsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.1", type: GalleryThumbsComponent, isStandalone: true, selector: "gallery-thumbs", inputs: { galleryId: "galleryId", state: "state", config: "config" }, outputs: { thumbClick: "thumbClick", error: "error" }, viewQueries: [{ propertyName: "sliderEl", first: true, predicate: ["slider"], descendants: true, static: true }, { propertyName: "items", predicate: GalleryThumbComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div #slider
         class="g-slider"
         [smoothScroll]="position$ | async"
         [smoothScrollInterruptOnMousemove]="!config.disableThumbMouseScroll"
         [attr.centralised]="config.thumbCentralized || adapter.isContentLessThanContainer"
         [hammerSliding]="!config.disableThumbMouseScroll"
         [galleryId]="galleryId"
         [items]="items$ | async"
         [state]="state"
         [config]="config"
         [adapter]="adapter"
         (thumbResizeObserver)="scrollToIndex(state.currIndex, 'auto')"
         (activeIndexChange)="onActiveIndexChange($event)">
      <div class="g-slider-content">
        <gallery-thumb *ngFor="let item of state.items; trackBy: trackByFn; index as i"
                       [attr.galleryId]="galleryId"
                       [type]="item.type"
                       [config]="config"
                       [data]="item.data"
                       [currIndex]="state.currIndex"
                       [index]="i"
                       [count]="state.items.length"
                       (click)="config.disableThumbs ? null : thumbClick.emit(i)"
                       (error)="error.emit({ itemIndex: i, error: $event })"/>
      </div>
    </div>
  `, isInline: true, styles: [":host{max-height:100%;max-width:100%;display:block;z-index:100}.g-slider{display:flex;align-items:center;transition:var(--g-height-transition);max-height:100%;min-width:100%;height:var(--thumb-slider-height);width:var(--thumb-slider-width);top:var(--thumb-slider-top);left:var(--thumb-slider-left);overflow:var(--thumb-slider-overflow);scroll-snap-type:var(--slider-scroll-snap-type);flex-direction:var(--thumb-slider-flex-direction);scrollbar-width:none}.g-slider::-webkit-scrollbar{display:none}.g-slider.g-sliding .g-slider-content{pointer-events:none}.g-slider[centralised=true]:before,.g-slider[centralised=true]:after{content:\"\"}.g-slider[centralised=true]:before{flex:0 0 var(--thumb-centralize-start-size)}.g-slider[centralised=true]:after{flex:0 0 var(--thumb-centralize-end-size)}.g-slider-content{flex:0 0 auto;display:flex;flex-direction:var(--thumb-slider-flex-direction);align-items:center;gap:1px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "pipe", type: i1.AsyncPipe, name: "async" }, { kind: "component", type: GalleryThumbComponent, selector: "gallery-thumb", inputs: ["config", "index", "count", "currIndex", "type", "data"], outputs: ["error"] }, { kind: "directive", type: SmoothScroll, selector: "[smoothScroll]", inputs: ["smoothScroll", "adapter", "config", "smoothScrollInterruptOnMousemove"], outputs: ["isScrollingChange"] }, { kind: "directive", type: HammerSliding, selector: "[hammerSliding]", inputs: ["hammerSliding", "galleryId", "items", "adapter", "state", "config"], outputs: ["activeIndexChange", "isSlidingChange"] }, { kind: "directive", type: ThumbResizeObserver, selector: "[thumbResizeObserver]", inputs: ["config", "adapter"], outputs: ["thumbResizeObserver"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GalleryThumbsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'gallery-thumbs', changeDetection: ChangeDetectionStrategy.OnPush, template: `
    <div #slider
         class="g-slider"
         [smoothScroll]="position$ | async"
         [smoothScrollInterruptOnMousemove]="!config.disableThumbMouseScroll"
         [attr.centralised]="config.thumbCentralized || adapter.isContentLessThanContainer"
         [hammerSliding]="!config.disableThumbMouseScroll"
         [galleryId]="galleryId"
         [items]="items$ | async"
         [state]="state"
         [config]="config"
         [adapter]="adapter"
         (thumbResizeObserver)="scrollToIndex(state.currIndex, 'auto')"
         (activeIndexChange)="onActiveIndexChange($event)">
      <div class="g-slider-content">
        <gallery-thumb *ngFor="let item of state.items; trackBy: trackByFn; index as i"
                       [attr.galleryId]="galleryId"
                       [type]="item.type"
                       [config]="config"
                       [data]="item.data"
                       [currIndex]="state.currIndex"
                       [index]="i"
                       [count]="state.items.length"
                       (click)="config.disableThumbs ? null : thumbClick.emit(i)"
                       (error)="error.emit({ itemIndex: i, error: $event })"/>
      </div>
    </div>
  `, standalone: true, imports: [CommonModule, GalleryThumbComponent, SmoothScroll, HammerSliding, ThumbResizeObserver], styles: [":host{max-height:100%;max-width:100%;display:block;z-index:100}.g-slider{display:flex;align-items:center;transition:var(--g-height-transition);max-height:100%;min-width:100%;height:var(--thumb-slider-height);width:var(--thumb-slider-width);top:var(--thumb-slider-top);left:var(--thumb-slider-left);overflow:var(--thumb-slider-overflow);scroll-snap-type:var(--slider-scroll-snap-type);flex-direction:var(--thumb-slider-flex-direction);scrollbar-width:none}.g-slider::-webkit-scrollbar{display:none}.g-slider.g-sliding .g-slider-content{pointer-events:none}.g-slider[centralised=true]:before,.g-slider[centralised=true]:after{content:\"\"}.g-slider[centralised=true]:before{flex:0 0 var(--thumb-centralize-start-size)}.g-slider[centralised=true]:after{flex:0 0 var(--thumb-centralize-end-size)}.g-slider-content{flex:0 0 auto;display:flex;flex-direction:var(--thumb-slider-flex-direction);align-items:center;gap:1px}\n"] }]
        }], propDecorators: { galleryId: [{
                type: Input
            }], state: [{
                type: Input
            }], config: [{
                type: Input
            }], thumbClick: [{
                type: Output
            }], error: [{
                type: Output
            }], sliderEl: [{
                type: ViewChild,
                args: ['slider', { static: true }]
            }], items: [{
                type: ViewChildren,
                args: [GalleryThumbComponent]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2FsbGVyeS10aHVtYnMuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmctZ2FsbGVyeS9zcmMvbGliL2NvbXBvbmVudHMvZ2FsbGVyeS10aHVtYnMuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsS0FBSyxFQUNMLE1BQU0sRUFDTixTQUFTLEVBQ1QsWUFBWSxFQUNaLFlBQVksRUFHWixTQUFTLEVBR1QsdUJBQXVCLEVBQ3hCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBQWMsT0FBTyxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFHM0QsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDekQsT0FBTyxFQUFFLGVBQWUsRUFBRSxpQkFBaUIsRUFBaUIsTUFBTSxZQUFZLENBQUM7QUFDL0UsT0FBTyxFQUFFLFlBQVksRUFBdUIsTUFBTSxrQkFBa0IsQ0FBQztBQUNyRSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUNsRSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFDckUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sOENBQThDLENBQUM7OztBQXFDbkYsTUFBTSxPQUFPLHNCQUFzQjtJQW5DbkM7UUFxQ0UsNENBQTRDO1FBQ25DLGNBQVMsR0FBaUMsSUFBSSxPQUFPLEVBQXVCLENBQUM7UUFpQnRGLDhDQUE4QztRQUNwQyxlQUFVLEdBQXlCLElBQUksWUFBWSxFQUFVLENBQUM7UUFFeEUsNkNBQTZDO1FBQ25DLFVBQUssR0FBK0IsSUFBSSxZQUFZLEVBQWdCLENBQUM7UUFLMUMsVUFBSyxHQUFxQyxJQUFJLFNBQVMsRUFBeUIsQ0FB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biAgT3V0cHV0LFxyXG4gIFZpZXdDaGlsZCxcclxuICBWaWV3Q2hpbGRyZW4sXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIEFmdGVyVmlld0luaXQsXHJcbiAgT25DaGFuZ2VzLFxyXG4gIFF1ZXJ5TGlzdCxcclxuICBTaW1wbGVDaGFuZ2VzLFxyXG4gIEVsZW1lbnRSZWYsXHJcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCwgbWFwLCBzdGFydFdpdGggfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgR2FsbGVyeUNvbmZpZyB9IGZyb20gJy4uL21vZGVscy9jb25maWcubW9kZWwnO1xyXG5pbXBvcnQgeyBHYWxsZXJ5U3RhdGUsIEdhbGxlcnlFcnJvciB9IGZyb20gJy4uL21vZGVscy9nYWxsZXJ5Lm1vZGVsJztcclxuaW1wb3J0IHsgVGh1bWJuYWlsc1Bvc2l0aW9uIH0gZnJvbSAnLi4vbW9kZWxzL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IFZlcnRpY2FsQWRhcHRlciwgSG9yaXpvbnRhbEFkYXB0ZXIsIFNsaWRlckFkYXB0ZXIgfSBmcm9tICcuL2FkYXB0ZXJzJztcclxuaW1wb3J0IHsgU21vb3RoU2Nyb2xsLCBTbW9vdGhTY3JvbGxPcHRpb25zIH0gZnJvbSAnLi4vc21vb3RoLXNjcm9sbCc7XHJcbmltcG9ydCB7IEdhbGxlcnlUaHVtYkNvbXBvbmVudCB9IGZyb20gJy4vZ2FsbGVyeS10aHVtYi5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBIYW1tZXJTbGlkaW5nIH0gZnJvbSAnLi4vZ2VzdHVyZXMvaGFtbWVyLXNsaWRpbmcuZGlyZWN0aXZlJztcclxuaW1wb3J0IHsgVGh1bWJSZXNpemVPYnNlcnZlciB9IGZyb20gJy4uL29ic2VydmVycy90aHVtYi1yZXNpemUtb2JzZXJ2ZXIuZGlyZWN0aXZlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnZ2FsbGVyeS10aHVtYnMnLFxyXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gIHN0eWxlVXJsczogWycuL2dhbGxlcnktdGh1bWJzLnNjc3MnXSxcclxuICB0ZW1wbGF0ZTogYFxyXG4gICAgPGRpdiAjc2xpZGVyXHJcbiAgICAgICAgIGNsYXNzPVwiZy1zbGlkZXJcIlxyXG4gICAgICAgICBbc21vb3RoU2Nyb2xsXT1cInBvc2l0aW9uJCB8IGFzeW5jXCJcclxuICAgICAgICAgW3Ntb290aFNjcm9sbEludGVycnVwdE9uTW91c2Vtb3ZlXT1cIiFjb25maWcuZGlzYWJsZVRodW1iTW91c2VTY3JvbGxcIlxyXG4gICAgICAgICBbYXR0ci5jZW50cmFsaXNlZF09XCJjb25maWcudGh1bWJDZW50cmFsaXplZCB8fCBhZGFwdGVyLmlzQ29udGVudExlc3NUaGFuQ29udGFpbmVyXCJcclxuICAgICAgICAgW2hhbW1lclNsaWRpbmddPVwiIWNvbmZpZy5kaXNhYmxlVGh1bWJNb3VzZVNjcm9sbFwiXHJcbiAgICAgICAgIFtnYWxsZXJ5SWRdPVwiZ2FsbGVyeUlkXCJcclxuICAgICAgICAgW2l0ZW1zXT1cIml0ZW1zJCB8IGFzeW5jXCJcclxuICAgICAgICAgW3N0YXRlXT1cInN0YXRlXCJcclxuICAgICAgICAgW2NvbmZpZ109XCJjb25maWdcIlxyXG4gICAgICAgICBbYWRhcHRlcl09XCJhZGFwdGVyXCJcclxuICAgICAgICAgKHRodW1iUmVzaXplT2JzZXJ2ZXIpPVwic2Nyb2xsVG9JbmRleChzdGF0ZS5jdXJySW5kZXgsICdhdXRvJylcIlxyXG4gICAgICAgICAoYWN0aXZlSW5kZXhDaGFuZ2UpPVwib25BY3RpdmVJbmRleENoYW5nZSgkZXZlbnQpXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJnLXNsaWRlci1jb250ZW50XCI+XHJcbiAgICAgICAgPGdhbGxlcnktdGh1bWIgKm5nRm9yPVwibGV0IGl0ZW0gb2Ygc3RhdGUuaXRlbXM7IHRyYWNrQnk6IHRyYWNrQnlGbjsgaW5kZXggYXMgaVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuZ2FsbGVyeUlkXT1cImdhbGxlcnlJZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgW3R5cGVdPVwiaXRlbS50eXBlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICBbY29uZmlnXT1cImNvbmZpZ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgW2RhdGFdPVwiaXRlbS5kYXRhXCJcclxuICAgICAgICAgICAgICAgICAgICAgICBbY3VyckluZGV4XT1cInN0YXRlLmN1cnJJbmRleFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgW2luZGV4XT1cImlcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgIFtjb3VudF09XCJzdGF0ZS5pdGVtcy5sZW5ndGhcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJjb25maWcuZGlzYWJsZVRodW1icyA/IG51bGwgOiB0aHVtYkNsaWNrLmVtaXQoaSlcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgIChlcnJvcik9XCJlcnJvci5lbWl0KHsgaXRlbUluZGV4OiBpLCBlcnJvcjogJGV2ZW50IH0pXCIvPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gIGAsXHJcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcclxuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBHYWxsZXJ5VGh1bWJDb21wb25lbnQsIFNtb290aFNjcm9sbCwgSGFtbWVyU2xpZGluZywgVGh1bWJSZXNpemVPYnNlcnZlcl1cclxufSlcclxuZXhwb3J0IGNsYXNzIEdhbGxlcnlUaHVtYnNDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkNoYW5nZXMge1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgdGhlIHNsaWRlciBwb3NpdGlvbiAqL1xyXG4gIHJlYWRvbmx5IHBvc2l0aW9uJDogU3ViamVjdDxTbW9vdGhTY3JvbGxPcHRpb25zPiA9IG5ldyBTdWJqZWN0PFNtb290aFNjcm9sbE9wdGlvbnM+KCk7XHJcblxyXG4gIC8qKiBTbGlkZXIgYWRhcHRlciAqL1xyXG4gIGFkYXB0ZXI6IFNsaWRlckFkYXB0ZXI7XHJcblxyXG4gIC8qKiBTdHJlYW0gdGhhdCBlbWl0cyB0aGUgdGh1bWIgY29tcG9uZW50cyBvbmNlIHRoZXkncmUgaW5pdGlhbGl6ZWQgKi9cclxuICBpdGVtcyQ6IE9ic2VydmFibGU8R2FsbGVyeVRodW1iQ29tcG9uZW50W10+O1xyXG5cclxuICAvKiogR2FsbGVyeSBJRCAqL1xyXG4gIEBJbnB1dCgpIGdhbGxlcnlJZDogc3RyaW5nO1xyXG5cclxuICAvKiogR2FsbGVyeSBzdGF0ZSAqL1xyXG4gIEBJbnB1dCgpIHN0YXRlOiBHYWxsZXJ5U3RhdGU7XHJcblxyXG4gIC8qKiBHYWxsZXJ5IGNvbmZpZyAqL1xyXG4gIEBJbnB1dCgpIGNvbmZpZzogR2FsbGVyeUNvbmZpZztcclxuXHJcbiAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gdGh1bWIgaXMgY2xpY2tlZCAqL1xyXG4gIEBPdXRwdXQoKSB0aHVtYkNsaWNrOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBhbiBlcnJvciBvY2N1cnMgKi9cclxuICBAT3V0cHV0KCkgZXJyb3I6IEV2ZW50RW1pdHRlcjxHYWxsZXJ5RXJyb3I+ID0gbmV3IEV2ZW50RW1pdHRlcjxHYWxsZXJ5RXJyb3I+KCk7XHJcblxyXG4gIC8qKiBTbGlkZXIgRWxlbWVudFJlZiAqL1xyXG4gIEBWaWV3Q2hpbGQoJ3NsaWRlcicsIHsgc3RhdGljOiB0cnVlIH0pIHNsaWRlckVsOiBFbGVtZW50UmVmO1xyXG5cclxuICBAVmlld0NoaWxkcmVuKEdhbGxlcnlUaHVtYkNvbXBvbmVudCkgaXRlbXM6IFF1ZXJ5TGlzdDxHYWxsZXJ5VGh1bWJDb21wb25lbnQ+ID0gbmV3IFF1ZXJ5TGlzdDxHYWxsZXJ5VGh1bWJDb21wb25lbnQ+KCk7XHJcblxyXG4gIGdldCBzbGlkZXIoKTogSFRNTEVsZW1lbnQge1xyXG4gICAgcmV0dXJuIHRoaXMuc2xpZGVyRWwubmF0aXZlRWxlbWVudDtcclxuICB9XHJcblxyXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgIGlmIChjaGFuZ2VzLmNvbmZpZykge1xyXG4gICAgICAvLyBTZXRzIHNsaWRpbmcgZGlyZWN0aW9uXHJcbiAgICAgIGlmIChjaGFuZ2VzLmNvbmZpZy5jdXJyZW50VmFsdWU/LnRodW1iUG9zaXRpb24gIT09IGNoYW5nZXMuY29uZmlnLnByZXZpb3VzVmFsdWU/LnRodW1iUG9zaXRpb24pIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuY29uZmlnLnRodW1iUG9zaXRpb24pIHtcclxuICAgICAgICAgIGNhc2UgVGh1bWJuYWlsc1Bvc2l0aW9uLlJpZ2h0OlxyXG4gICAgICAgICAgY2FzZSBUaHVtYm5haWxzUG9zaXRpb24uTGVmdDpcclxuICAgICAgICAgICAgdGhpcy5hZGFwdGVyID0gbmV3IFZlcnRpY2FsQWRhcHRlcih0aGlzLnNsaWRlciwgdGhpcy5jb25maWcpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgVGh1bWJuYWlsc1Bvc2l0aW9uLlRvcDpcclxuICAgICAgICAgIGNhc2UgVGh1bWJuYWlsc1Bvc2l0aW9uLkJvdHRvbTpcclxuICAgICAgICAgICAgdGhpcy5hZGFwdGVyID0gbmV3IEhvcml6b250YWxBZGFwdGVyKHRoaXMuc2xpZGVyLCB0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmNvbmZpZy5maXJzdENoYW5nZSkge1xyXG4gICAgICAgICAgLy8gS2VlcCB0aGUgY29ycmVjdCBzbGlkaW5nIHBvc2l0aW9uIHdoZW4gZGlyZWN0aW9uIGNoYW5nZXNcclxuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleCh0aGlzLnN0YXRlLmN1cnJJbmRleCwgJ2F1dG8nKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChjaGFuZ2VzLnN0YXRlICYmIChjaGFuZ2VzLnN0YXRlLmZpcnN0Q2hhbmdlIHx8ICF0aGlzLmNvbmZpZy5kZXRhY2hUaHVtYnMpKSB7XHJcbiAgICAgIGlmIChjaGFuZ2VzLnN0YXRlLmN1cnJlbnRWYWx1ZT8uY3VyckluZGV4ICE9PSBjaGFuZ2VzLnN0YXRlLnByZXZpb3VzVmFsdWU/LmN1cnJJbmRleCkge1xyXG4gICAgICAgIC8vIFNjcm9sbCBzbGlkZSB0byBpdGVtIHdoZW4gY3VycmVudCBpbmRleCBjaGFuZ2VzLlxyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLnNjcm9sbFRvSW5kZXgodGhpcy5zdGF0ZS5jdXJySW5kZXgsIGNoYW5nZXMuc3RhdGU/LmZpcnN0Q2hhbmdlID8gJ2F1dG8nIDogJ3Ntb290aCcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XHJcbiAgICB0aGlzLml0ZW1zLm5vdGlmeU9uQ2hhbmdlcygpO1xyXG4gICAgdGhpcy5pdGVtcyQgPSB0aGlzLml0ZW1zLmNoYW5nZXMucGlwZShcclxuICAgICAgLy8gSW4gc29tZSBjYXNlcywgaXRlbXMgaXMgbm90IG5vdGlmaWVkIGF0IGZpcnN0LCBuZWVkIHRvIGZvcmNlIHN0YXJ0IHRoZSBzdHJlYW1cclxuICAgICAgc3RhcnRXaXRoKG51bGwpLFxyXG4gICAgICBtYXAoKCkgPT4gdGhpcy5pdGVtcy50b0FycmF5KCkpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgdHJhY2tCeUZuKGluZGV4OiBudW1iZXIsIGl0ZW06IGFueSkge1xyXG4gICAgcmV0dXJuIGl0ZW0udHlwZTtcclxuICB9XHJcblxyXG4gIG9uQWN0aXZlSW5kZXhDaGFuZ2UoaW5kZXg6IG51bWJlcik6IHZvaWQge1xyXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAvLyBSZXNldCBhY3RpdmUgaW5kZXggcG9zaXRpb25cclxuICAgICAgdGhpcy5zY3JvbGxUb0luZGV4KHRoaXMuc3RhdGUuY3VyckluZGV4LCAnc21vb3RoJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnNjcm9sbFRvSW5kZXgoaW5kZXgsICdzbW9vdGgnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNjcm9sbFRvSW5kZXgodmFsdWU6IG51bWJlciwgYmVoYXZpb3I6IFNjcm9sbEJlaGF2aW9yKTogdm9pZCB7XHJcbiAgICBjb25zdCBlbDogSFRNTEVsZW1lbnQgPSB0aGlzLml0ZW1zLmdldCh2YWx1ZSk/Lm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICBpZiAoZWwpIHtcclxuICAgICAgY29uc3QgcG9zOiBTbW9vdGhTY3JvbGxPcHRpb25zID0gdGhpcy5hZGFwdGVyLmdldFNjcm9sbFRvVmFsdWUoZWwsIGJlaGF2aW9yKTtcclxuICAgICAgdGhpcy5wb3NpdGlvbiQubmV4dChwb3MpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=