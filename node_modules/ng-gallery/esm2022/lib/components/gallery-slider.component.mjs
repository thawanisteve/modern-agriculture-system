import { Component, Input, Output, ViewChild, ViewChildren, EventEmitter, QueryList, ChangeDetectionStrategy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Subject, map, startWith } from 'rxjs';
import { Orientation } from '../models/constants';
import { HorizontalAdapter, VerticalAdapter } from './adapters';
import { SmoothScroll } from '../smooth-scroll';
import { HammerSliding } from '../gestures/hammer-sliding.directive';
import { SliderIntersectionObserver } from '../observers/slider-intersection-observer.directive';
import { ItemIntersectionObserver } from '../observers/item-intersection-observer.directive';
import { GalleryItemComponent } from './gallery-item.component';
import { SliderResizeObserver } from '../observers/slider-resize-observer.directive';
import * as i0 from "@angular/core";
import * as i1 from "../services/gallery.service";
import * as i2 from "@angular/common";
export class GallerySliderComponent {
    get slider() {
        return this.sliderEl.nativeElement;
    }
    constructor(_gallery) {
        this._gallery = _gallery;
        /** Stream that emits the slider position */
        this.position$ = new Subject();
        /** Stream that emits when item is clicked */
        this.itemClick = new EventEmitter();
        /** Stream that emits when an error occurs */
        this.error = new EventEmitter();
        this.items = new QueryList();
    }
    ngOnChanges(changes) {
        if (changes.config) {
            if (changes.config.currentValue?.orientation !== changes.config.previousValue?.orientation) {
                switch (this.config.orientation) {
                    case Orientation.Horizontal:
                        this.adapter = new HorizontalAdapter(this.slider, this.config);
                        break;
                    case Orientation.Vertical:
                        this.adapter = new VerticalAdapter(this.slider, this.config);
                        break;
                }
            }
            if (!changes.config.firstChange) {
                // Keep the correct sliding position when direction changes
                requestAnimationFrame(() => {
                    this.scrollToIndex(this.state.currIndex, 'auto');
                });
            }
        }
        // Scroll to current index
        if (changes.state) {
            if (changes.state.currentValue?.currIndex !== changes.state.previousValue?.currIndex) {
                requestAnimationFrame(() => {
                    this.scrollToIndex(this.state.currIndex, changes.state.firstChange ? 'auto' : this.state.behavior);
                });
            }
        }
    }
    ngAfterViewInit() {
        this.items.notifyOnChanges();
        this.items$ = this.items.changes.pipe(
        // In some cases, items is not notified at first, need to force start the stream
        startWith(null), map(() => this.items.toArray()));
    }
    trackByFn(index, item) {
        return item.type;
    }
    onActiveIndexChange(index) {
        if (index === -1) {
            // Reset active index position
            this.scrollToIndex(this.state.currIndex, 'smooth');
        }
        else {
            this._gallery.ref(this.galleryId).set(index, 'smooth');
        }
    }
    scrollToIndex(index, behavior) {
        const el = this.items.get(index)?.nativeElement;
        if (el) {
            const pos = this.adapter.getScrollToValue(el, behavior || this.config.scrollBehavior);
            this.position$.next(pos);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GallerySliderComponent, deps: [{ token: i1.Gallery }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.2.1", type: GallerySliderComponent, isStandalone: true, selector: "gallery-slider", inputs: { galleryId: "galleryId", state: "state", config: "config" }, outputs: { itemClick: "itemClick", error: "error" }, viewQueries: [{ propertyName: "sliderEl", first: true, predicate: ["slider"], descendants: true, static: true }, { propertyName: "items", predicate: GalleryItemComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <div #slider
         class="g-slider"
         [attr.centralised]="config.itemAutosize"
         [smoothScroll]="position$ | async"
         [smoothScrollInterruptOnMousemove]="!config.disableMouseScroll"
         sliderIntersectionObserver
         [sliderIntersectionObserverDisabled]="isScrolling || isSliding || isResizing"
         [hammerSliding]="!config.disableMouseScroll"
         [adapter]="adapter"
         [items]="items$ | async"
         [config]="config"
         [state]="state"
         [galleryId]="galleryId"
         (isScrollingChange)="isScrolling = $event"
         (isSlidingChange)="isSliding = $event"
         (activeIndexChange)="onActiveIndexChange($event)"
         (isResizingChange)="isResizing = $event"
         sliderResizeObserver>
      <div class="g-slider-content">
        <gallery-item *ngFor="let item of state.items; trackBy: trackByFn index as i"
                      [attr.galleryId]="galleryId"
                      [type]="item.type"
                      [config]="config"
                      [data]="item.data"
                      [currIndex]="state.currIndex"
                      [index]="i"
                      [count]="state.items.length"
                      itemIntersectionObserver
                      [itemIntersectionObserverDisabled]="isScrolling || isSliding || isResizing"
                      [adapter]="adapter"
                      (activeIndexChange)="onActiveIndexChange($event)"
                      (click)="itemClick.emit(i)"
                      (error)="error.emit({ itemIndex: i, error: $event })"/>
      </div>

      <div *ngIf="config.debug" class="g-slider-debug">
        <div class="g-slider-resizing">RESIZING</div>
        <div class="g-slider-scrolling">SCROLLING</div>
        <div class="g-slider-sliding">SLIDING</div>
      </div>
    </div>
    <ng-content></ng-content>
  `, isInline: true, styles: [":host{position:relative;display:flex;align-items:center;justify-content:center;overflow:hidden;order:1;flex:1}.g-slider{display:flex;align-items:center;transition:var(--g-height-transition);min-height:100%;min-width:100%;max-height:100%;max-width:100%;height:var(--slider-height, 100%);width:var(--slider-width, 100%);overflow:var(--slider-overflow);scroll-snap-type:var(--slider-scroll-snap-type);flex-direction:var(--slider-flex-direction);scrollbar-width:none}.g-slider::-webkit-scrollbar{display:none}.g-slider.g-sliding .g-slider-content,.g-slider.g-scrolling .g-slider-content{pointer-events:none}.g-slider[centralised=true]:before,.g-slider[centralised=true]:after{content:\"\"}.g-slider[centralised=true]:before{flex:0 0 var(--slider-centralize-start-size)}.g-slider[centralised=true]:after{flex:0 0 var(--slider-centralize-end-size)}.g-slider-content{flex:0 0 auto;display:flex;align-items:center;gap:1px;width:var(--slider-content-width, unset);height:var(--slider-content-height, unset);flex-direction:var(--slider-flex-direction)}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i2.AsyncPipe, name: "async" }, { kind: "component", type: GalleryItemComponent, selector: "gallery-item", inputs: ["config", "index", "count", "currIndex", "type", "data"], outputs: ["error"] }, { kind: "directive", type: SmoothScroll, selector: "[smoothScroll]", inputs: ["smoothScroll", "adapter", "config", "smoothScrollInterruptOnMousemove"], outputs: ["isScrollingChange"] }, { kind: "directive", type: HammerSliding, selector: "[hammerSliding]", inputs: ["hammerSliding", "galleryId", "items", "adapter", "state", "config"], outputs: ["activeIndexChange", "isSlidingChange"] }, { kind: "directive", type: SliderIntersectionObserver, selector: "[sliderIntersectionObserver]", inputs: ["adapter", "items", "config", "sliderIntersectionObserverDisabled"], outputs: ["activeIndexChange"] }, { kind: "directive", type: ItemIntersectionObserver, selector: "[itemIntersectionObserver]", inputs: ["adapter", "config", "itemIntersectionObserverDisabled"], outputs: ["activeIndexChange"] }, { kind: "directive", type: SliderResizeObserver, selector: "[sliderResizeObserver]", inputs: ["galleryId", "adapter", "config"], outputs: ["isResizingChange"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.1", ngImport: i0, type: GallerySliderComponent, decorators: [{
            type: Component,
            args: [{ selector: 'gallery-slider', changeDetection: ChangeDetectionStrategy.OnPush, template: `
    <div #slider
         class="g-slider"
         [attr.centralised]="config.itemAutosize"
         [smoothScroll]="position$ | async"
         [smoothScrollInterruptOnMousemove]="!config.disableMouseScroll"
         sliderIntersectionObserver
         [sliderIntersectionObserverDisabled]="isScrolling || isSliding || isResizing"
         [hammerSliding]="!config.disableMouseScroll"
         [adapter]="adapter"
         [items]="items$ | async"
         [config]="config"
         [state]="state"
         [galleryId]="galleryId"
         (isScrollingChange)="isScrolling = $event"
         (isSlidingChange)="isSliding = $event"
         (activeIndexChange)="onActiveIndexChange($event)"
         (isResizingChange)="isResizing = $event"
         sliderResizeObserver>
      <div class="g-slider-content">
        <gallery-item *ngFor="let item of state.items; trackBy: trackByFn index as i"
                      [attr.galleryId]="galleryId"
                      [type]="item.type"
                      [config]="config"
                      [data]="item.data"
                      [currIndex]="state.currIndex"
                      [index]="i"
                      [count]="state.items.length"
                      itemIntersectionObserver
                      [itemIntersectionObserverDisabled]="isScrolling || isSliding || isResizing"
                      [adapter]="adapter"
                      (activeIndexChange)="onActiveIndexChange($event)"
                      (click)="itemClick.emit(i)"
                      (error)="error.emit({ itemIndex: i, error: $event })"/>
      </div>

      <div *ngIf="config.debug" class="g-slider-debug">
        <div class="g-slider-resizing">RESIZING</div>
        <div class="g-slider-scrolling">SCROLLING</div>
        <div class="g-slider-sliding">SLIDING</div>
      </div>
    </div>
    <ng-content></ng-content>
  `, standalone: true, imports: [CommonModule, GalleryItemComponent, SmoothScroll, HammerSliding, SliderIntersectionObserver, ItemIntersectionObserver, SliderResizeObserver], styles: [":host{position:relative;display:flex;align-items:center;justify-content:center;overflow:hidden;order:1;flex:1}.g-slider{display:flex;align-items:center;transition:var(--g-height-transition);min-height:100%;min-width:100%;max-height:100%;max-width:100%;height:var(--slider-height, 100%);width:var(--slider-width, 100%);overflow:var(--slider-overflow);scroll-snap-type:var(--slider-scroll-snap-type);flex-direction:var(--slider-flex-direction);scrollbar-width:none}.g-slider::-webkit-scrollbar{display:none}.g-slider.g-sliding .g-slider-content,.g-slider.g-scrolling .g-slider-content{pointer-events:none}.g-slider[centralised=true]:before,.g-slider[centralised=true]:after{content:\"\"}.g-slider[centralised=true]:before{flex:0 0 var(--slider-centralize-start-size)}.g-slider[centralised=true]:after{flex:0 0 var(--slider-centralize-end-size)}.g-slider-content{flex:0 0 auto;display:flex;align-items:center;gap:1px;width:var(--slider-content-width, unset);height:var(--slider-content-height, unset);flex-direction:var(--slider-flex-direction)}\n"] }]
        }], ctorParameters: () => [{ type: i1.Gallery }], propDecorators: { galleryId: [{
                type: Input
            }], state: [{
                type: Input
            }], config: [{
                type: Input
            }], itemClick: [{
                type: Output
            }], error: [{
                type: Output
            }], sliderEl: [{
                type: ViewChild,
                args: ['slider', { static: true }]
            }], items: [{
                type: ViewChildren,
                args: [GalleryItemComponent]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2FsbGVyeS1zbGlkZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmctZ2FsbGVyeS9zcmMvbGliL2NvbXBvbmVudHMvZ2FsbGVyeS1zbGlkZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsS0FBSyxFQUNMLE1BQU0sRUFDTixTQUFTLEVBQ1QsWUFBWSxFQUNaLFlBQVksRUFLWixTQUFTLEVBQ1QsdUJBQXVCLEVBQ3hCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBQWMsT0FBTyxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFJM0QsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ2xELE9BQU8sRUFBaUIsaUJBQWlCLEVBQUUsZUFBZSxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQy9FLE9BQU8sRUFBRSxZQUFZLEVBQXVCLE1BQU0sa0JBQWtCLENBQUM7QUFDckUsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBQ3JFLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLHFEQUFxRCxDQUFDO0FBQ2pHLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLG1EQUFtRCxDQUFDO0FBQzdGLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLCtDQUErQyxDQUFDOzs7O0FBcURyRixNQUFNLE9BQU8sc0JBQXNCO0lBcUNqQyxJQUFJLE1BQU07UUFDUixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDO0lBQ3JDLENBQUM7SUFFRCxZQUFvQixRQUFpQjtRQUFqQixhQUFRLEdBQVIsUUFBUSxD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QUE5QyxTQUFTO3VCQUFDLFFBQVEsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0JBRUQsS0FBSztzQkFBeEMsWUFBWTt1QkFBQyxvQkFBb0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIENvbXBvbmVudCxcclxuICBJbnB1dCxcclxuICBPdXRwdXQsXHJcbiAgVmlld0NoaWxkLFxyXG4gIFZpZXdDaGlsZHJlbixcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgQWZ0ZXJWaWV3SW5pdCxcclxuICBPbkNoYW5nZXMsXHJcbiAgU2ltcGxlQ2hhbmdlcyxcclxuICBFbGVtZW50UmVmLFxyXG4gIFF1ZXJ5TGlzdCxcclxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBtYXAsIHN0YXJ0V2l0aCB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBHYWxsZXJ5IH0gZnJvbSAnLi4vc2VydmljZXMvZ2FsbGVyeS5zZXJ2aWNlJztcclxuaW1wb3J0IHsgR2FsbGVyeVN0YXRlLCBHYWxsZXJ5RXJyb3IgfSBmcm9tICcuLi9tb2RlbHMvZ2FsbGVyeS5tb2RlbCc7XHJcbmltcG9ydCB7IEdhbGxlcnlDb25maWcgfSBmcm9tICcuLi9tb2RlbHMvY29uZmlnLm1vZGVsJztcclxuaW1wb3J0IHsgT3JpZW50YXRpb24gfSBmcm9tICcuLi9tb2RlbHMvY29uc3RhbnRzJztcclxuaW1wb3J0IHsgU2xpZGVyQWRhcHRlciwgSG9yaXpvbnRhbEFkYXB0ZXIsIFZlcnRpY2FsQWRhcHRlciB9IGZyb20gJy4vYWRhcHRlcnMnO1xyXG5pbXBvcnQgeyBTbW9vdGhTY3JvbGwsIFNtb290aFNjcm9sbE9wdGlvbnMgfSBmcm9tICcuLi9zbW9vdGgtc2Nyb2xsJztcclxuaW1wb3J0IHsgSGFtbWVyU2xpZGluZyB9IGZyb20gJy4uL2dlc3R1cmVzL2hhbW1lci1zbGlkaW5nLmRpcmVjdGl2ZSc7XHJcbmltcG9ydCB7IFNsaWRlckludGVyc2VjdGlvbk9ic2VydmVyIH0gZnJvbSAnLi4vb2JzZXJ2ZXJzL3NsaWRlci1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXIuZGlyZWN0aXZlJztcclxuaW1wb3J0IHsgSXRlbUludGVyc2VjdGlvbk9ic2VydmVyIH0gZnJvbSAnLi4vb2JzZXJ2ZXJzL2l0ZW0taW50ZXJzZWN0aW9uLW9ic2VydmVyLmRpcmVjdGl2ZSc7XHJcbmltcG9ydCB7IEdhbGxlcnlJdGVtQ29tcG9uZW50IH0gZnJvbSAnLi9nYWxsZXJ5LWl0ZW0uY29tcG9uZW50JztcclxuaW1wb3J0IHsgU2xpZGVyUmVzaXplT2JzZXJ2ZXIgfSBmcm9tICcuLi9vYnNlcnZlcnMvc2xpZGVyLXJlc2l6ZS1vYnNlcnZlci5kaXJlY3RpdmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdnYWxsZXJ5LXNsaWRlcicsXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgc3R5bGVVcmxzOiBbJy4vZ2FsbGVyeS1zbGlkZXIuc2NzcyddLFxyXG4gIHRlbXBsYXRlOiBgXHJcbiAgICA8ZGl2ICNzbGlkZXJcclxuICAgICAgICAgY2xhc3M9XCJnLXNsaWRlclwiXHJcbiAgICAgICAgIFthdHRyLmNlbnRyYWxpc2VkXT1cImNvbmZpZy5pdGVtQXV0b3NpemVcIlxyXG4gICAgICAgICBbc21vb3RoU2Nyb2xsXT1cInBvc2l0aW9uJCB8IGFzeW5jXCJcclxuICAgICAgICAgW3Ntb290aFNjcm9sbEludGVycnVwdE9uTW91c2Vtb3ZlXT1cIiFjb25maWcuZGlzYWJsZU1vdXNlU2Nyb2xsXCJcclxuICAgICAgICAgc2xpZGVySW50ZXJzZWN0aW9uT2JzZXJ2ZXJcclxuICAgICAgICAgW3NsaWRlckludGVyc2VjdGlvbk9ic2VydmVyRGlzYWJsZWRdPVwiaXNTY3JvbGxpbmcgfHwgaXNTbGlkaW5nIHx8IGlzUmVzaXppbmdcIlxyXG4gICAgICAgICBbaGFtbWVyU2xpZGluZ109XCIhY29uZmlnLmRpc2FibGVNb3VzZVNjcm9sbFwiXHJcbiAgICAgICAgIFthZGFwdGVyXT1cImFkYXB0ZXJcIlxyXG4gICAgICAgICBbaXRlbXNdPVwiaXRlbXMkIHwgYXN5bmNcIlxyXG4gICAgICAgICBbY29uZmlnXT1cImNvbmZpZ1wiXHJcbiAgICAgICAgIFtzdGF0ZV09XCJzdGF0ZVwiXHJcbiAgICAgICAgIFtnYWxsZXJ5SWRdPVwiZ2FsbGVyeUlkXCJcclxuICAgICAgICAgKGlzU2Nyb2xsaW5nQ2hhbmdlKT1cImlzU2Nyb2xsaW5nID0gJGV2ZW50XCJcclxuICAgICAgICAgKGlzU2xpZGluZ0NoYW5nZSk9XCJpc1NsaWRpbmcgPSAkZXZlbnRcIlxyXG4gICAgICAgICAoYWN0aXZlSW5kZXhDaGFuZ2UpPVwib25BY3RpdmVJbmRleENoYW5nZSgkZXZlbnQpXCJcclxuICAgICAgICAgKGlzUmVzaXppbmdDaGFuZ2UpPVwiaXNSZXNpemluZyA9ICRldmVudFwiXHJcbiAgICAgICAgIHNsaWRlclJlc2l6ZU9ic2VydmVyPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiZy1zbGlkZXItY29udGVudFwiPlxyXG4gICAgICAgIDxnYWxsZXJ5LWl0ZW0gKm5nRm9yPVwibGV0IGl0ZW0gb2Ygc3RhdGUuaXRlbXM7IHRyYWNrQnk6IHRyYWNrQnlGbiBpbmRleCBhcyBpXCJcclxuICAgICAgICAgICAgICAgICAgICAgIFthdHRyLmdhbGxlcnlJZF09XCJnYWxsZXJ5SWRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgW3R5cGVdPVwiaXRlbS50eXBlXCJcclxuICAgICAgICAgICAgICAgICAgICAgIFtjb25maWddPVwiY29uZmlnXCJcclxuICAgICAgICAgICAgICAgICAgICAgIFtkYXRhXT1cIml0ZW0uZGF0YVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICBbY3VyckluZGV4XT1cInN0YXRlLmN1cnJJbmRleFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICBbaW5kZXhdPVwiaVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICBbY291bnRdPVwic3RhdGUuaXRlbXMubGVuZ3RoXCJcclxuICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JbnRlcnNlY3Rpb25PYnNlcnZlclxyXG4gICAgICAgICAgICAgICAgICAgICAgW2l0ZW1JbnRlcnNlY3Rpb25PYnNlcnZlckRpc2FibGVkXT1cImlzU2Nyb2xsaW5nIHx8IGlzU2xpZGluZyB8fCBpc1Jlc2l6aW5nXCJcclxuICAgICAgICAgICAgICAgICAgICAgIFthZGFwdGVyXT1cImFkYXB0ZXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgKGFjdGl2ZUluZGV4Q2hhbmdlKT1cIm9uQWN0aXZlSW5kZXhDaGFuZ2UoJGV2ZW50KVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwiaXRlbUNsaWNrLmVtaXQoaSlcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgKGVycm9yKT1cImVycm9yLmVtaXQoeyBpdGVtSW5kZXg6IGksIGVycm9yOiAkZXZlbnQgfSlcIi8+XHJcbiAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgPGRpdiAqbmdJZj1cImNvbmZpZy5kZWJ1Z1wiIGNsYXNzPVwiZy1zbGlkZXItZGVidWdcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZy1zbGlkZXItcmVzaXppbmdcIj5SRVNJWklORzwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJnLXNsaWRlci1zY3JvbGxpbmdcIj5TQ1JPTExJTkc8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZy1zbGlkZXItc2xpZGluZ1wiPlNMSURJTkc8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cclxuICBgLFxyXG4gIHN0YW5kYWxvbmU6IHRydWUsXHJcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgR2FsbGVyeUl0ZW1Db21wb25lbnQsIFNtb290aFNjcm9sbCwgSGFtbWVyU2xpZGluZywgU2xpZGVySW50ZXJzZWN0aW9uT2JzZXJ2ZXIsIEl0ZW1JbnRlcnNlY3Rpb25PYnNlcnZlciwgU2xpZGVyUmVzaXplT2JzZXJ2ZXJdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBHYWxsZXJ5U2xpZGVyQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25DaGFuZ2VzIHtcclxuXHJcbiAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHRoZSBzbGlkZXIgcG9zaXRpb24gKi9cclxuICByZWFkb25seSBwb3NpdGlvbiQ6IFN1YmplY3Q8U21vb3RoU2Nyb2xsT3B0aW9ucz4gPSBuZXcgU3ViamVjdDxTbW9vdGhTY3JvbGxPcHRpb25zPigpO1xyXG5cclxuICAvKiogU2xpZGVyIGFkYXB0ZXIgKi9cclxuICBhZGFwdGVyOiBTbGlkZXJBZGFwdGVyO1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgdGhlIGl0ZW0gY29tcG9uZW50cyBvbmNlIHRoZXkncmUgaW5pdGlhbGl6ZWQgKi9cclxuICBpdGVtcyQ6IE9ic2VydmFibGU8R2FsbGVyeUl0ZW1Db21wb25lbnRbXT47XHJcblxyXG4gIGlzU2Nyb2xsaW5nOiBib29sZWFuO1xyXG5cclxuICBpc1NsaWRpbmc6IGJvb2xlYW47XHJcblxyXG4gIGlzUmVzaXppbmc6IGJvb2xlYW47XHJcblxyXG4gIC8qKiBHYWxsZXJ5IElEICovXHJcbiAgQElucHV0KCkgZ2FsbGVyeUlkOiBzdHJpbmc7XHJcblxyXG4gIC8qKiBHYWxsZXJ5IHN0YXRlICovXHJcbiAgQElucHV0KCkgc3RhdGU6IEdhbGxlcnlTdGF0ZTtcclxuXHJcbiAgLyoqIEdhbGxlcnkgY29uZmlnICovXHJcbiAgQElucHV0KCkgY29uZmlnOiBHYWxsZXJ5Q29uZmlnO1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBpdGVtIGlzIGNsaWNrZWQgKi9cclxuICBAT3V0cHV0KCkgaXRlbUNsaWNrOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xyXG5cclxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBhbiBlcnJvciBvY2N1cnMgKi9cclxuICBAT3V0cHV0KCkgZXJyb3I6IEV2ZW50RW1pdHRlcjxHYWxsZXJ5RXJyb3I+ID0gbmV3IEV2ZW50RW1pdHRlcjxHYWxsZXJ5RXJyb3I+KCk7XHJcblxyXG4gIC8qKiBTbGlkZXIgRWxlbWVudFJlZiAqL1xyXG4gIEBWaWV3Q2hpbGQoJ3NsaWRlcicsIHsgc3RhdGljOiB0cnVlIH0pIHNsaWRlckVsOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PjtcclxuXHJcbiAgQFZpZXdDaGlsZHJlbihHYWxsZXJ5SXRlbUNvbXBvbmVudCkgaXRlbXM6IFF1ZXJ5TGlzdDxHYWxsZXJ5SXRlbUNvbXBvbmVudD4gPSBuZXcgUXVlcnlMaXN0PEdhbGxlcnlJdGVtQ29tcG9uZW50PigpO1xyXG5cclxuICBnZXQgc2xpZGVyKCk6IEhUTUxFbGVtZW50IHtcclxuICAgIHJldHVybiB0aGlzLnNsaWRlckVsLm5hdGl2ZUVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9nYWxsZXJ5OiBHYWxsZXJ5KSB7XHJcbiAgfVxyXG5cclxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XHJcbiAgICBpZiAoY2hhbmdlcy5jb25maWcpIHtcclxuICAgICAgaWYgKGNoYW5nZXMuY29uZmlnLmN1cnJlbnRWYWx1ZT8ub3JpZW50YXRpb24gIT09IGNoYW5nZXMuY29uZmlnLnByZXZpb3VzVmFsdWU/Lm9yaWVudGF0aW9uKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmNvbmZpZy5vcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgY2FzZSBPcmllbnRhdGlvbi5Ib3Jpem9udGFsOlxyXG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIgPSBuZXcgSG9yaXpvbnRhbEFkYXB0ZXIodGhpcy5zbGlkZXIsIHRoaXMuY29uZmlnKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIE9yaWVudGF0aW9uLlZlcnRpY2FsOlxyXG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXIgPSBuZXcgVmVydGljYWxBZGFwdGVyKHRoaXMuc2xpZGVyLCB0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoIWNoYW5nZXMuY29uZmlnLmZpcnN0Q2hhbmdlKSB7XHJcbiAgICAgICAgLy8gS2VlcCB0aGUgY29ycmVjdCBzbGlkaW5nIHBvc2l0aW9uIHdoZW4gZGlyZWN0aW9uIGNoYW5nZXNcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5zY3JvbGxUb0luZGV4KHRoaXMuc3RhdGUuY3VyckluZGV4LCAnYXV0bycpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2Nyb2xsIHRvIGN1cnJlbnQgaW5kZXhcclxuICAgIGlmIChjaGFuZ2VzLnN0YXRlKSB7XHJcbiAgICAgIGlmIChjaGFuZ2VzLnN0YXRlLmN1cnJlbnRWYWx1ZT8uY3VyckluZGV4ICE9PSBjaGFuZ2VzLnN0YXRlLnByZXZpb3VzVmFsdWU/LmN1cnJJbmRleCkge1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLnNjcm9sbFRvSW5kZXgodGhpcy5zdGF0ZS5jdXJySW5kZXgsIGNoYW5nZXMuc3RhdGUuZmlyc3RDaGFuZ2UgPyAnYXV0bycgOiB0aGlzLnN0YXRlLmJlaGF2aW9yKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xyXG4gICAgdGhpcy5pdGVtcy5ub3RpZnlPbkNoYW5nZXMoKTtcclxuICAgIHRoaXMuaXRlbXMkID0gdGhpcy5pdGVtcy5jaGFuZ2VzLnBpcGUoXHJcbiAgICAgIC8vIEluIHNvbWUgY2FzZXMsIGl0ZW1zIGlzIG5vdCBub3RpZmllZCBhdCBmaXJzdCwgbmVlZCB0byBmb3JjZSBzdGFydCB0aGUgc3RyZWFtXHJcbiAgICAgIHN0YXJ0V2l0aChudWxsKSxcclxuICAgICAgbWFwKCgpID0+IHRoaXMuaXRlbXMudG9BcnJheSgpKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHRyYWNrQnlGbihpbmRleDogbnVtYmVyLCBpdGVtOiBhbnkpIHtcclxuICAgIHJldHVybiBpdGVtLnR5cGU7XHJcbiAgfVxyXG5cclxuICBvbkFjdGl2ZUluZGV4Q2hhbmdlKGluZGV4OiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgLy8gUmVzZXQgYWN0aXZlIGluZGV4IHBvc2l0aW9uXHJcbiAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleCh0aGlzLnN0YXRlLmN1cnJJbmRleCwgJ3Ntb290aCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fZ2FsbGVyeS5yZWYodGhpcy5nYWxsZXJ5SWQpLnNldChpbmRleCwgJ3Ntb290aCcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzY3JvbGxUb0luZGV4KGluZGV4OiBudW1iZXIsIGJlaGF2aW9yOiBTY3JvbGxCZWhhdmlvcik6IHZvaWQge1xyXG4gICAgY29uc3QgZWw6IEhUTUxFbGVtZW50ID0gdGhpcy5pdGVtcy5nZXQoaW5kZXgpPy5uYXRpdmVFbGVtZW50O1xyXG4gICAgaWYgKGVsKSB7XHJcbiAgICAgIGNvbnN0IHBvczogU21vb3RoU2Nyb2xsT3B0aW9ucyA9IHRoaXMuYWRhcHRlci5nZXRTY3JvbGxUb1ZhbHVlKGVsLCBiZWhhdmlvciB8fCB0aGlzLmNvbmZpZy5zY3JvbGxCZWhhdmlvcik7XHJcbiAgICAgIHRoaXMucG9zaXRpb24kLm5leHQocG9zKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19